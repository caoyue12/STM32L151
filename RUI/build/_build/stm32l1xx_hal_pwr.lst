ARM GAS  /tmp/ccmFWlTF.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32l1xx_hal_pwr.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  16              		.align	1
  17              		.global	HAL_PWR_DeInit
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	HAL_PWR_DeInit:
  24              	.LFB72:
  25              		.file 1 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c"
   1:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
   2:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   ******************************************************************************
   3:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @file    stm32l1xx_hal_pwr.c
   4:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @author  MCD Application Team
   5:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
   7:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   8:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   9:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
  10:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           + Peripheral Control functions
  11:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
  12:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   ******************************************************************************
  13:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @attention
  14:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
  15:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
  16:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  17:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
  18:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  19:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * the "License"; You may not use this file except in compliance with the
  20:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * License. You may obtain a copy of the License at:
  21:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *                        opensource.org/licenses/BSD-3-Clause
  22:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
  23:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   ******************************************************************************
  24:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  25:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  26:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  27:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #include "stm32l1xx_hal.h"
  28:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  29:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /** @addtogroup STM32L1xx_HAL_Driver
  30:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @{
  31:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  32:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  33:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /** @defgroup PWR PWR
ARM GAS  /tmp/ccmFWlTF.s 			page 2


  34:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief    PWR HAL module driver
  35:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @{
  36:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  37:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  38:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  39:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  40:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  41:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  42:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #define PVD_MODE_IT               (0x00010000U)
  43:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #define PVD_MODE_EVT              (0x00020000U)
  44:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #define PVD_RISING_EDGE           (0x00000001U)
  45:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #define PVD_FALLING_EDGE          (0x00000002U)
  46:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  47:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Private macro -------------------------------------------------------------*/
  48:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
  49:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  50:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
  51:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  52:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
  53:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @{
  54:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  55:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  56:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions
  57:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *  @brief   Initialization and de-initialization functions
  58:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
  59:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** @verbatim
  60:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****  ===============================================================================
  61:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
  62:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****  ===============================================================================
  63:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
  64:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
  65:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       registers) is protected against possible unwanted
  66:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       write accesses.
  67:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
  68:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
  69:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
  70:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
  71:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  72:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** @endverbatim
  73:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @{
  74:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  75:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  76:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
  77:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.
  78:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note   Before calling this function, the VOS[1:0] bits should be configured
  79:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         to "10" and the system frequency has to be configured accordingly.
  80:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         To configure the VOS[1:0] bits, use the PWR_VoltageScalingConfig()
  81:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         function.
  82:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note   ULP and FWU bits are not reset by this function.
  83:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
  84:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  85:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
  86:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
  26              		.loc 1 86 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccmFWlTF.s 			page 3


  30              		@ link register save eliminated.
  87:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
  31              		.loc 1 87 0
  32 0000 044B     		ldr	r3, .L2
  33 0002 9A69     		ldr	r2, [r3, #24]
  34 0004 42F08052 		orr	r2, r2, #268435456
  35 0008 9A61     		str	r2, [r3, #24]
  88:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
  36              		.loc 1 88 0
  37 000a 9A69     		ldr	r2, [r3, #24]
  38 000c 22F08052 		bic	r2, r2, #268435456
  39 0010 9A61     		str	r2, [r3, #24]
  40 0012 7047     		bx	lr
  41              	.L3:
  42              		.align	2
  43              	.L2:
  44 0014 00380240 		.word	1073887232
  45              		.cfi_endproc
  46              	.LFE72:
  48              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
  49              		.align	1
  50              		.global	HAL_PWR_EnableBkUpAccess
  51              		.syntax unified
  52              		.thumb
  53              		.thumb_func
  54              		.fpu softvfp
  56              	HAL_PWR_EnableBkUpAccess:
  57              	.LFB73:
  89:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
  90:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
  91:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
  92:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  Enables access to the backup domain (RTC registers, RTC
  93:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         backup data registers ).
  94:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note   If the HSE divided by 2, 4, 8 or 16 is used as the RTC clock, the
  95:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
  96:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
  97:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
  98:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
  99:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
  58              		.loc 1 99 0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL0:
  64              	.LBB14:
  65              	.LBB15:
  66              		.file 2 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h"
   1:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /*
   8:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
ARM GAS  /tmp/ccmFWlTF.s 			page 4


  10:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  12:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  16:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  18:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
  24:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  25:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  28:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  34:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  38:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  39:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  43:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  46:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  49:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  55:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  58:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  61:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  64:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccmFWlTF.s 			page 5


  67:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  70:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  78:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  86:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  94:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 102:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 110:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 113:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 116:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 117:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 118:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   @{
 122:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 123:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccmFWlTF.s 			page 6


 124:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 125:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 129:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 131:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 133:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 134:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 135:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 136:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 140:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 142:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 144:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 145:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 146:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 147:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 151:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 153:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 155:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 158:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 159:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 160:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 162:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 166:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 168:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 170:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 173:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 174:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 175:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 176:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 177:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccmFWlTF.s 			page 7


 181:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 183:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 185:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 186:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 187:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 189:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 193:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 195:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 197:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 198:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 199:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 200:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 201:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 205:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 207:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 209:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 212:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 213:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 214:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 215:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 219:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 221:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 223:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 226:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 227:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 228:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 229:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 233:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 235:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 237:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
ARM GAS  /tmp/ccmFWlTF.s 			page 8


 238:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 240:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 241:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 242:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 243:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 247:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 249:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 251:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 254:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 255:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 256:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 258:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 262:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 264:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 266:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 269:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 270:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 271:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 272:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 273:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 277:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 279:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 281:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 282:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 283:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 285:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 289:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 291:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 293:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 294:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccmFWlTF.s 			page 9


 295:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 296:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 297:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 301:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 303:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 305:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 308:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 309:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 310:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 312:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 316:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 318:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 320:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 323:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 324:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 325:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 326:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 327:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 331:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 333:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 335:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 336:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 337:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 339:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 343:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 345:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 347:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 348:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 349:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 350:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccmFWlTF.s 			page 10


 352:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 356:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 358:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 360:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 363:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 364:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 365:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 366:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 370:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 372:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 374:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 375:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 376:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 377:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 378:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 382:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 384:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 386:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 389:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 390:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 391:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 393:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 397:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 399:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 401:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 404:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 405:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 406:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 407:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 408:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
ARM GAS  /tmp/ccmFWlTF.s 			page 11


 409:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 412:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 414:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 416:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 417:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 418:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 420:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 424:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 426:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 428:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 429:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 430:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 431:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 435:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 439:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 441:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 443:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 444:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 445:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 446:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 450:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 452:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 454:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 455:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 456:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 457:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 461:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 463:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 465:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
ARM GAS  /tmp/ccmFWlTF.s 			page 12


 466:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 468:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 469:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 470:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 472:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 476:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 478:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 480:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 483:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 484:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 485:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 486:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 487:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 491:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 493:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 495:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 496:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 497:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 499:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 503:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 505:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 507:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 508:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 509:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 510:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 511:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 516:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 518:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 520:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 521:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 522:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccmFWlTF.s 			page 13


 523:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 527:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 529:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 531:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 534:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 535:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 536:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 538:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 542:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 544:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 546:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 549:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 550:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 551:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 552:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 553:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 557:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 559:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 561:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 562:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 563:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 565:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 569:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 571:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 573:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 574:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 575:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 579:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccmFWlTF.s 			page 14


 580:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 583:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 584:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   
 589:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 592:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 594:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 599:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 603:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 604:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 605:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 607:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 611:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 614:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 616:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 620:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 624:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 625:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 626:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 627:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 628:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 629:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   
 634:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccmFWlTF.s 			page 15


 637:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 639:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 644:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 646:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 647:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 648:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 649:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 651:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 655:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 658:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 660:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 664:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 666:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 667:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 668:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 669:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 670:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 671:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 676:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 679:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 681:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 686:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 690:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 691:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 692:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 693:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
ARM GAS  /tmp/ccmFWlTF.s 			page 16


 694:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 695:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 699:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 702:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 704:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 708:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 712:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 713:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 714:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 715:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 716:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 717:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 722:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 725:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 727:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 732:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 734:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 735:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 736:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 737:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 739:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 743:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 746:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 748:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
ARM GAS  /tmp/ccmFWlTF.s 			page 17


 751:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 752:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 754:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 755:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 756:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 757:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 760:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 761:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 762:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 766:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 768:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 776:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 778:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 781:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 782:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 784:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 785:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 786:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 787:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 788:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 792:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 794:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 802:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 804:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 805:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 807:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccmFWlTF.s 			page 18


 808:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 809:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 810:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 812:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 813:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   @{
 817:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** */
 818:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 819:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 827:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 831:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 832:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 833:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 836:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 838:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 839:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 842:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 844:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 845:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 846:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 850:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 852:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 853:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 854:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 857:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 859:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 860:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 861:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
ARM GAS  /tmp/ccmFWlTF.s 			page 19


 865:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 866:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 868:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 870:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 871:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 872:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 873:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 877:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 879:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 881:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 882:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 883:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 884:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 888:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 890:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 892:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 893:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 894:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 895:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 900:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 902:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 905:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 907:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 910:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 911:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 912:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 913:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 914:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 919:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 921:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
ARM GAS  /tmp/ccmFWlTF.s 			page 20


 922:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 923:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 926:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 927:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 928:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 929:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 934:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 936:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 939:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 941:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 944:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 945:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 946:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 947:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 948:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 954:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 956:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   {
 959:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     return op1;
 960:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   }
 961:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 963:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 964:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 965:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 966:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 972:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 974:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 975:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 976:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
ARM GAS  /tmp/ccmFWlTF.s 			page 21


 979:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 981:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 983:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 985:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
  67              		.loc 2 988 0
  68 0000 4FF48073 		mov	r3, #256
  69              		.syntax unified
  70              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
  71 0004 93FAA3F3 		rbit r3, r3
  72              	@ 0 "" 2
  73              	.LVL1:
  74              		.thumb
  75              		.syntax unified
  76              	.LBE15:
  77              	.LBE14:
 100:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Enable access to RTC and backup registers */
 101:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
  78              		.loc 1 101 0
  79 0008 B3FA83F3 		clz	r3, r3
  80 000c 9B00     		lsls	r3, r3, #2
  81 000e 03F18443 		add	r3, r3, #1107296256
  82 0012 03F56023 		add	r3, r3, #917504
  83 0016 0122     		movs	r2, #1
  84 0018 1A60     		str	r2, [r3]
  85 001a 7047     		bx	lr
  86              		.cfi_endproc
  87              	.LFE73:
  89              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
  90              		.align	1
  91              		.global	HAL_PWR_DisableBkUpAccess
  92              		.syntax unified
  93              		.thumb
  94              		.thumb_func
  95              		.fpu softvfp
  97              	HAL_PWR_DisableBkUpAccess:
  98              	.LFB74:
 102:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 103:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 104:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 105:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  Disables access to the backup domain (RTC registers, RTC
 106:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         backup data registers).
 107:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note   If the HSE divided by 2, 4, 8 or 16 is used as the RTC clock, the
 108:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 109:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 110:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 111:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 112:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
  99              		.loc 1 112 0
 100              		.cfi_startproc
 101              		@ args = 0, pretend = 0, frame = 0
 102              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccmFWlTF.s 			page 22


 103              		@ link register save eliminated.
 104              	.LVL2:
 105              	.LBB16:
 106              	.LBB17:
 107              		.loc 2 988 0
 108 0000 4FF48073 		mov	r3, #256
 109              		.syntax unified
 110              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 111 0004 93FAA3F3 		rbit r3, r3
 112              	@ 0 "" 2
 113              	.LVL3:
 114              		.thumb
 115              		.syntax unified
 116              	.LBE17:
 117              	.LBE16:
 113:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Disable access to RTC and backup registers */
 114:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
 118              		.loc 1 114 0
 119 0008 B3FA83F3 		clz	r3, r3
 120 000c 9B00     		lsls	r3, r3, #2
 121 000e 03F18443 		add	r3, r3, #1107296256
 122 0012 03F56023 		add	r3, r3, #917504
 123 0016 0022     		movs	r2, #0
 124 0018 1A60     		str	r2, [r3]
 125 001a 7047     		bx	lr
 126              		.cfi_endproc
 127              	.LFE74:
 129              		.section	.text.HAL_PWR_ConfigPVD,"ax",%progbits
 130              		.align	1
 131              		.global	HAL_PWR_ConfigPVD
 132              		.syntax unified
 133              		.thumb
 134              		.thumb_func
 135              		.fpu softvfp
 137              	HAL_PWR_ConfigPVD:
 138              	.LFB75:
 115:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 116:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 117:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 118:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @}
 119:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 120:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 121:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions
 122:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief    Low Power modes configuration functions
 123:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *
 124:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** @verbatim
 125:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 126:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****  ===============================================================================
 127:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 128:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****  ===============================================================================
 129:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 130:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     *** PVD configuration ***
 131:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     =========================
 132:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 133:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 134:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 135:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) The PVD can use an external input analog voltage (PVD_IN) which is compared
ARM GAS  /tmp/ccmFWlTF.s 			page 23


 136:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       internally to VREFINT. The PVD_IN (PB7) has to be configured in Analog mode
 137:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       when PWR_PVDLevel_7 is selected (PLS[2:0] = 111).
 138:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 139:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower
 140:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 141:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           line16 and can generate an interrupt if enabled. This is done through
 142:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.
 143:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
 144:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 145:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 146:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     ================================
 147:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 148:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) WakeUp pin is used to wake up the system from Standby mode. This pin is
 149:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           forced in input pull-down configuration and is active on rising edges.
 150:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) There are two or three WakeUp pins:
 151:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           WakeUp Pin 1 on PA.00.
 152:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           WakeUp Pin 2 on PC.13.
 153:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           WakeUp Pin 3 on PE.06. : Only on product with GPIOE available
 154:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 155:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 156:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     *** Main and Backup Regulators configuration ***
 157:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     ================================================
 158:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 159:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) The main internal regulator can be configured to have a tradeoff between
 160:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           performance and power consumption when the device does not operate at
 161:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           the maximum frequency. This is done through __HAL_PWR_VOLTAGESCALING_CONFIG()
 162:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           macro which configure VOS bit in PWR_CR register:
 163:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) When this bit is set (Regulator voltage output Scale 1 mode selected)
 164:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              the System frequency can go up to 32 MHz.
 165:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) When this bit is reset (Regulator voltage output Scale 2 mode selected)
 166:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              the System frequency can go up to 16 MHz.
 167:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) When this bit is reset (Regulator voltage output Scale 3 mode selected)
 168:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              the System frequency can go up to 4.2 MHz.
 169:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 170:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         Refer to the datasheets for more details.
 171:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 172:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     *** Low Power modes configuration ***
 173:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     =====================================
 174:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****      [..]
 175:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       The device features 5 low-power modes:
 176:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Low power run mode: regulator in low power mode, limited clock frequency,
 177:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         limited number of peripherals running.
 178:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Sleep mode: Cortex-M3 core stopped, peripherals kept running.
 179:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Low power sleep mode: Cortex-M3 core stopped, limited clock frequency,
 180:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****          limited number of peripherals running, regulator in low power mode.
 181:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Stop mode: All clocks are stopped, regulator running, regulator in low power mode.
 182:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Standby mode: VCORE domain powered off
 183:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 184:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    *** Low power run mode ***
 185:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    =========================
 186:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 187:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****        To further reduce the consumption when the system is in Run mode, the regulator can be
 188:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         configured in low power mode. In this mode, the system frequency should not exceed
 189:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         MSI frequency range1.
 190:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         In Low power run mode, all I/O pins keep the same state as in Run mode.
 191:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 192:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Entry:
ARM GAS  /tmp/ccmFWlTF.s 			page 24


 193:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) VCORE in range2
 194:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) Decrease the system frequency tonot exceed the frequency of MSI frequency range1.
 195:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) The regulator is forced in low power mode using the HAL_PWREx_EnableLowPowerRunMode()
 196:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              function.
 197:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Exit:
 198:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) The regulator is forced in Main regulator mode using the HAL_PWREx_DisableLowPowerRunM
 199:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               function.
 200:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) Increase the system frequency if needed.
 201:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 202:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    *** Sleep mode ***
 203:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    ==================
 204:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 205:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Entry:
 206:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_S
 207:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               functions with
 208:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 209:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 210:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 211:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Exit:
 212:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt
 213:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               controller (NVIC) can wake up the device from Sleep mode.
 214:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 215:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    *** Low power sleep mode ***
 216:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    ============================
 217:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 218:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Entry:
 219:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           The Low power sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_LOWPOWERREGUL
 220:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               functions with
 221:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 222:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 223:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****        (+) The Flash memory can be switched off by using the control bits (SLEEP_PD in the FLASH_AC
 224:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              This reduces power consumption but increases the wake-up time.
 225:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 226:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Exit:
 227:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) If the WFI instruction was used to enter Low power sleep mode, any peripheral interrup
 228:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               acknowledged by the nested vectored interrupt controller (NVIC) can wake up the devic
 229:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               from Low power sleep mode. If the WFE instruction was used to enter Low power sleep m
 230:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****               the MCU exits Sleep mode as soon as an event occurs.
 231:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 232:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    *** Stop mode ***
 233:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    =================
 234:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 235:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       The Stop mode is based on the Cortex-M3 deepsleep mode combined with peripheral
 236:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       clock gating. The voltage regulator can be configured either in normal or low-power mode.
 237:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       In Stop mode, all clocks in the VCORE domain are stopped, the PLL, the MSI, the HSI and
 238:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       the HSE RC oscillators are disabled. Internal SRAM and register contents are preserved.
 239:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       To get the lowest consumption in Stop mode, the internal Flash memory also enters low
 240:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       power mode. When the Flash memory is in power-down mode, an additional startup delay is
 241:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       incurred when waking up from Stop mode.
 242:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       To minimize the consumption In Stop mode, VREFINT, the BOR, PVD, and temperature
 243:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       sensor can be switched off before entering Stop mode. They can be switched on again by
 244:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       software after exiting Stop mode using the ULP bit in the PWR_CR register.
 245:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       In Stop mode, all I/O pins keep the same state as in Run mode.
 246:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 247:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Entry:
 248:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****            The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_SLEEP
 249:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              function with:
ARM GAS  /tmp/ccmFWlTF.s 			page 25


 250:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) Main regulator ON.
 251:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) Low Power regulator ON.
 252:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 253:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 254:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Exit:
 255:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) By issuing an interrupt or a wakeup event, the MSI RC oscillator is selected as system
 256:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 257:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    *** Standby mode ***
 258:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    ====================
 259:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****      [..]
 260:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based on the
 261:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       Cortex-M3 deepsleep mode, with the voltage regulator disabled. The VCORE domain is
 262:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       consequently powered off. The PLL, the MSI, the HSI oscillator and the HSE oscillator are
 263:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       also switched off. SRAM and register contents are lost except for the RTC registers, RTC
 264:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       backup registers and Standby circuitry.
 265:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 266:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       To minimize the consumption In Standby mode, VREFINT, the BOR, PVD, and temperature
 267:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****        sensor can be switched off before entering the Standby mode. They can be switched
 268:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****        on again by software after exiting the Standby mode.
 269:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****        function.
 270:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 271:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Entry:
 272:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 273:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       (+) Exit:
 274:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 275:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              tamper event, time-stamp event, external reset in NRST pin, IWDG reset.
 276:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 277:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 278:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****    =============================================
 279:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     [..]
 280:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC
 281:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       Wakeup event, a tamper event, a time-stamp event, or a comparator event,
 282:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****       without depending on an external interrupt (Auto-wakeup mode).
 283:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 284:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Stop mode
 285:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 286:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt
 287:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    or Event modes) and Enable the RTC Alarm Interrupt using the HAL_RTC_SetAlarm_IT
 288:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    function
 289:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the RTC to generate the RTC alarm using the HAL_RTC_Init()
 290:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    and HAL_RTC_SetTime() functions.
 291:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it
 292:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              is necessary to:
 293:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the EXTI Line 19 to be sensitive to rising edges (Interrupt or Event m
 294:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    Enable the RTC Tamper or time stamp Interrupt using the HAL_RTCEx_SetTamper_IT()
 295:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    or HAL_RTCEx_SetTimeStamp_IT() functions.
 296:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
 297:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the EXTI Line 20 to be sensitive to rising edges (Interrupt or Event m
 298:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    Enable the RTC WakeUp Interrupt using the HAL_RTCEx_SetWakeUpTimer_IT() function
 299:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the RTC to generate the RTC WakeUp event using the HAL_RTCEx_SetWakeUp
 300:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    function.
 301:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 302:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Standby mode
 303:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 304:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Enable the RTC Alarm Interrupt using the HAL_RTC_SetAlarm_IT() function.
 305:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the RTC to generate the RTC alarm using the HAL_RTC_Init()
 306:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    and HAL_RTC_SetTime() functions.
ARM GAS  /tmp/ccmFWlTF.s 			page 26


 307:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it
 308:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              is necessary to:
 309:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Enable the RTC Tamper or time stamp Interrupt and Configure the RTC to
 310:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    detect the tamper or time stamp event using the HAL_RTCEx_SetTimeStamp_IT()
 311:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    or HAL_RTCEx_SetTamper_IT()functions.
 312:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
 313:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Enable the RTC WakeUp Interrupt and Configure the RTC to generate the RTC WakeUp
 314:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    using the HAL_RTCEx_SetWakeUpTimer_IT() and HAL_RTCEx_SetWakeUpTimer() functions
 315:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 316:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     (+) Comparator auto-wakeup (AWU) from the Stop mode
 317:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****         (++) To wake up from the Stop mode with an comparator 1 or comparator 2 wakeup
 318:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              event, it is necessary to:
 319:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the EXTI Line 21 or EXTI Line 22 for comparator to be sensitive to to 
 320:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    selected edges (falling, rising or falling and rising) (Interrupt or Event modes
 321:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****                    the COMP functions.
 322:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****              (+++) Configure the comparator to generate the event.
 323:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 324:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 325:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 326:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** @endverbatim
 327:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @{
 328:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 329:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 330:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 331:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 332:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param  sConfigPVD pointer to an PWR_PVDTypeDef structure that contains the configuration
 333:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         information for the PVD.
 334:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 335:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         more details about the voltage threshold corresponding to each
 336:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         detection level.
 337:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 338:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 339:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 340:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 139              		.loc 1 340 0
 140              		.cfi_startproc
 141              		@ args = 0, pretend = 0, frame = 0
 142              		@ frame_needed = 0, uses_anonymous_args = 0
 143              		@ link register save eliminated.
 144              	.LVL4:
 341:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check the parameters */
 342:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 343:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 344:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 345:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Set PLS[7:5] bits according to PVDLevel value */
 346:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
 145              		.loc 1 346 0
 146 0000 1E4A     		ldr	r2, .L11
 147 0002 1368     		ldr	r3, [r2]
 148 0004 23F0E003 		bic	r3, r3, #224
 149 0008 0168     		ldr	r1, [r0]
 150 000a 0B43     		orrs	r3, r3, r1
 151 000c 1360     		str	r3, [r2]
 347:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 348:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Clear any previous config. Keep it clear if no event or IT mode is selected */
 349:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 152              		.loc 1 349 0
ARM GAS  /tmp/ccmFWlTF.s 			page 27


 153 000e 1C4B     		ldr	r3, .L11+4
 154 0010 5A68     		ldr	r2, [r3, #4]
 155 0012 22F48032 		bic	r2, r2, #65536
 156 0016 5A60     		str	r2, [r3, #4]
 350:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 157              		.loc 1 350 0
 158 0018 1A68     		ldr	r2, [r3]
 159 001a 22F48032 		bic	r2, r2, #65536
 160 001e 1A60     		str	r2, [r3]
 351:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE();
 161              		.loc 1 351 0
 162 0020 9A68     		ldr	r2, [r3, #8]
 163 0022 22F48032 		bic	r2, r2, #65536
 164 0026 9A60     		str	r2, [r3, #8]
 165 0028 DA68     		ldr	r2, [r3, #12]
 166 002a 22F48032 		bic	r2, r2, #65536
 167 002e DA60     		str	r2, [r3, #12]
 352:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 353:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Configure interrupt mode */
 354:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 168              		.loc 1 354 0
 169 0030 4368     		ldr	r3, [r0, #4]
 170 0032 13F4803F 		tst	r3, #65536
 171 0036 04D0     		beq	.L7
 355:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 356:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 172              		.loc 1 356 0
 173 0038 114A     		ldr	r2, .L11+4
 174 003a 1368     		ldr	r3, [r2]
 175 003c 43F48033 		orr	r3, r3, #65536
 176 0040 1360     		str	r3, [r2]
 177              	.L7:
 357:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 358:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 359:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Configure event mode */
 360:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 178              		.loc 1 360 0
 179 0042 4368     		ldr	r3, [r0, #4]
 180 0044 13F4003F 		tst	r3, #131072
 181 0048 04D0     		beq	.L8
 361:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 362:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 182              		.loc 1 362 0
 183 004a 0D4A     		ldr	r2, .L11+4
 184 004c 5368     		ldr	r3, [r2, #4]
 185 004e 43F48033 		orr	r3, r3, #65536
 186 0052 5360     		str	r3, [r2, #4]
 187              	.L8:
 363:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 364:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 365:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Configure the edge */
 366:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 188              		.loc 1 366 0
 189 0054 4368     		ldr	r3, [r0, #4]
 190 0056 13F0010F 		tst	r3, #1
 191 005a 04D0     		beq	.L9
 367:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
ARM GAS  /tmp/ccmFWlTF.s 			page 28


 368:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 192              		.loc 1 368 0
 193 005c 084A     		ldr	r2, .L11+4
 194 005e 9368     		ldr	r3, [r2, #8]
 195 0060 43F48033 		orr	r3, r3, #65536
 196 0064 9360     		str	r3, [r2, #8]
 197              	.L9:
 369:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 370:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 371:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 198              		.loc 1 371 0
 199 0066 4368     		ldr	r3, [r0, #4]
 200 0068 13F0020F 		tst	r3, #2
 201 006c 04D0     		beq	.L6
 372:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 373:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 202              		.loc 1 373 0
 203 006e 044A     		ldr	r2, .L11+4
 204 0070 D368     		ldr	r3, [r2, #12]
 205 0072 43F48033 		orr	r3, r3, #65536
 206 0076 D360     		str	r3, [r2, #12]
 207              	.L6:
 208 0078 7047     		bx	lr
 209              	.L12:
 210 007a 00BF     		.align	2
 211              	.L11:
 212 007c 00700040 		.word	1073770496
 213 0080 00040140 		.word	1073808384
 214              		.cfi_endproc
 215              	.LFE75:
 217              		.section	.text.HAL_PWR_EnablePVD,"ax",%progbits
 218              		.align	1
 219              		.global	HAL_PWR_EnablePVD
 220              		.syntax unified
 221              		.thumb
 222              		.thumb_func
 223              		.fpu softvfp
 225              	HAL_PWR_EnablePVD:
 226              	.LFB76:
 374:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 375:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 376:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 377:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 378:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  Enables the Power Voltage Detector(PVD).
 379:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 380:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 381:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
 382:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 227              		.loc 1 382 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              		@ link register save eliminated.
 232              	.LVL5:
 233              	.LBB18:
 234              	.LBB19:
 235              		.loc 2 988 0
ARM GAS  /tmp/ccmFWlTF.s 			page 29


 236 0000 1023     		movs	r3, #16
 237              		.syntax unified
 238              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 239 0002 93FAA3F3 		rbit r3, r3
 240              	@ 0 "" 2
 241              	.LVL6:
 242              		.thumb
 243              		.syntax unified
 244              	.LBE19:
 245              	.LBE18:
 383:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Enable the power voltage detector */
 384:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
 246              		.loc 1 384 0
 247 0006 B3FA83F3 		clz	r3, r3
 248 000a 9B00     		lsls	r3, r3, #2
 249 000c 03F18443 		add	r3, r3, #1107296256
 250 0010 03F56023 		add	r3, r3, #917504
 251 0014 0122     		movs	r2, #1
 252 0016 1A60     		str	r2, [r3]
 253 0018 7047     		bx	lr
 254              		.cfi_endproc
 255              	.LFE76:
 257              		.section	.text.HAL_PWR_DisablePVD,"ax",%progbits
 258              		.align	1
 259              		.global	HAL_PWR_DisablePVD
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
 263              		.fpu softvfp
 265              	HAL_PWR_DisablePVD:
 266              	.LFB77:
 385:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 386:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 387:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 388:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  Disables the Power Voltage Detector(PVD).
 389:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 390:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 391:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 392:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 267              		.loc 1 392 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              		@ link register save eliminated.
 272              	.LVL7:
 273              	.LBB20:
 274              	.LBB21:
 275              		.loc 2 988 0
 276 0000 1023     		movs	r3, #16
 277              		.syntax unified
 278              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 279 0002 93FAA3F3 		rbit r3, r3
 280              	@ 0 "" 2
 281              	.LVL8:
 282              		.thumb
 283              		.syntax unified
 284              	.LBE21:
ARM GAS  /tmp/ccmFWlTF.s 			page 30


 285              	.LBE20:
 393:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Disable the power voltage detector */
 394:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
 286              		.loc 1 394 0
 287 0006 B3FA83F3 		clz	r3, r3
 288 000a 9B00     		lsls	r3, r3, #2
 289 000c 03F18443 		add	r3, r3, #1107296256
 290 0010 03F56023 		add	r3, r3, #917504
 291 0014 0022     		movs	r2, #0
 292 0016 1A60     		str	r2, [r3]
 293 0018 7047     		bx	lr
 294              		.cfi_endproc
 295              	.LFE77:
 297              		.section	.text.HAL_PWR_EnableWakeUpPin,"ax",%progbits
 298              		.align	1
 299              		.global	HAL_PWR_EnableWakeUpPin
 300              		.syntax unified
 301              		.thumb
 302              		.thumb_func
 303              		.fpu softvfp
 305              	HAL_PWR_EnableWakeUpPin:
 306              	.LFB78:
 395:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 396:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 397:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 398:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Enables the WakeUp PINx functionality.
 399:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to enable.
 400:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 401:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 402:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN2
 403:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN3: Only on product with GPIOE available
 404:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 405:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 406:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
 407:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 307              		.loc 1 407 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL9:
 313              	.LBB22:
 314              	.LBB23:
 315              		.loc 2 988 0
 316              		.syntax unified
 317              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 318 0000 90FAA0F0 		rbit r0, r0
 319              	@ 0 "" 2
 320              	.LVL10:
 321              		.thumb
 322              		.syntax unified
 323              	.LBE23:
 324              	.LBE22:
 408:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check the parameter */
 409:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 410:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Enable the EWUPx pin */
 411:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
ARM GAS  /tmp/ccmFWlTF.s 			page 31


 325              		.loc 1 411 0
 326 0004 B0FA80F0 		clz	r0, r0
 327 0008 0122     		movs	r2, #1
 328 000a 024B     		ldr	r3, .L16
 329 000c 43F82020 		str	r2, [r3, r0, lsl #2]
 330 0010 7047     		bx	lr
 331              	.L17:
 332 0012 00BF     		.align	2
 333              	.L16:
 334 0014 80000E42 		.word	1108213888
 335              		.cfi_endproc
 336              	.LFE78:
 338              		.section	.text.HAL_PWR_DisableWakeUpPin,"ax",%progbits
 339              		.align	1
 340              		.global	HAL_PWR_DisableWakeUpPin
 341              		.syntax unified
 342              		.thumb
 343              		.thumb_func
 344              		.fpu softvfp
 346              	HAL_PWR_DisableWakeUpPin:
 347              	.LFB79:
 412:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 413:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 414:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 415:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Disables the WakeUp PINx functionality.
 416:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
 417:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 418:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 419:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN2
 420:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN3: Only on product with GPIOE available
 421:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 422:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 423:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 424:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 348              		.loc 1 424 0
 349              		.cfi_startproc
 350              		@ args = 0, pretend = 0, frame = 0
 351              		@ frame_needed = 0, uses_anonymous_args = 0
 352              		@ link register save eliminated.
 353              	.LVL11:
 354              	.LBB24:
 355              	.LBB25:
 356              		.loc 2 988 0
 357              		.syntax unified
 358              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 359 0000 90FAA0F0 		rbit r0, r0
 360              	@ 0 "" 2
 361              	.LVL12:
 362              		.thumb
 363              		.syntax unified
 364              	.LBE25:
 365              	.LBE24:
 425:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check the parameter */
 426:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 427:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Disable the EWUPx pin */
 428:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
 366              		.loc 1 428 0
ARM GAS  /tmp/ccmFWlTF.s 			page 32


 367 0004 B0FA80F0 		clz	r0, r0
 368 0008 0022     		movs	r2, #0
 369 000a 024B     		ldr	r3, .L19
 370 000c 43F82020 		str	r2, [r3, r0, lsl #2]
 371 0010 7047     		bx	lr
 372              	.L20:
 373 0012 00BF     		.align	2
 374              	.L19:
 375 0014 80000E42 		.word	1108213888
 376              		.cfi_endproc
 377              	.LFE79:
 379              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
 380              		.align	1
 381              		.global	HAL_PWR_EnterSLEEPMode
 382              		.syntax unified
 383              		.thumb
 384              		.thumb_func
 385              		.fpu softvfp
 387              	HAL_PWR_EnterSLEEPMode:
 388              	.LFB80:
 429:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 430:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 431:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 432:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Enters Sleep mode.
 433:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
 434:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param Regulator: Specifies the regulator state in SLEEP mode.
 435:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         This parameter can be one of the following values:
 436:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
 437:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
 438:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction.
 439:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           When WFI entry is used, tick interrupt have to be disabled if not desired as
 440:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           the interrupt wake up source.
 441:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *           This parameter can be one of the following values:
 442:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 443:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 444:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 445:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 446:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 447:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 389              		.loc 1 447 0
 390              		.cfi_startproc
 391              		@ args = 0, pretend = 0, frame = 0
 392              		@ frame_needed = 0, uses_anonymous_args = 0
 393              		@ link register save eliminated.
 394              	.LVL13:
 448:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check the parameters */
 449:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 450:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 451:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 452:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Select the regulator state in Sleep mode: Set PDDS and LPSDSR bit according to PWR_Regulator v
 453:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPSDSR), Regulator);
 395              		.loc 1 453 0
 396 0000 094A     		ldr	r2, .L25
 397 0002 1368     		ldr	r3, [r2]
 398 0004 23F00303 		bic	r3, r3, #3
 399 0008 1843     		orrs	r0, r0, r3
 400              	.LVL14:
ARM GAS  /tmp/ccmFWlTF.s 			page 33


 401 000a 1060     		str	r0, [r2]
 454:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 455:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 456:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 402              		.loc 1 456 0
 403 000c 074A     		ldr	r2, .L25+4
 404 000e 1369     		ldr	r3, [r2, #16]
 405 0010 23F00403 		bic	r3, r3, #4
 406 0014 1361     		str	r3, [r2, #16]
 457:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 458:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 459:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 407              		.loc 1 459 0
 408 0016 0129     		cmp	r1, #1
 409 0018 03D0     		beq	.L24
 460:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 461:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 462:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __WFI();
 463:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 464:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   else
 465:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 466:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     /* Request Wait For Event */
 467:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __SEV();
 410              		.loc 1 467 0
 411              		.syntax unified
 412              	@ 467 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 413 001a 40BF     		sev
 414              	@ 0 "" 2
 468:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __WFE();
 415              		.loc 1 468 0
 416              	@ 468 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 417 001c 20BF     		wfe
 418              	@ 0 "" 2
 469:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __WFE();
 419              		.loc 1 469 0
 420              	@ 469 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 421 001e 20BF     		wfe
 422              	@ 0 "" 2
 423              		.thumb
 424              		.syntax unified
 425 0020 7047     		bx	lr
 426              	.L24:
 462:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 427              		.loc 1 462 0
 428              		.syntax unified
 429              	@ 462 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 430 0022 30BF     		wfi
 431              	@ 0 "" 2
 432              		.thumb
 433              		.syntax unified
 434 0024 7047     		bx	lr
 435              	.L26:
 436 0026 00BF     		.align	2
 437              	.L25:
 438 0028 00700040 		.word	1073770496
 439 002c 00ED00E0 		.word	-536810240
 440              		.cfi_endproc
ARM GAS  /tmp/ccmFWlTF.s 			page 34


 441              	.LFE80:
 443              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 444              		.align	1
 445              		.global	HAL_PWR_EnterSTOPMode
 446              		.syntax unified
 447              		.thumb
 448              		.thumb_func
 449              		.fpu softvfp
 451              	HAL_PWR_EnterSTOPMode:
 452              	.LFB81:
 470:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 471:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 472:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 473:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 474:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Enters Stop mode.
 475:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
 476:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note  When exiting Stop mode by using an interrupt or a wakeup event,
 477:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *        MSI RC oscillator is selected as system clock.
 478:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note  When the voltage regulator operates in low power mode, an additional
 479:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         startup delay is incurred when waking up from Stop mode.
 480:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 481:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *         is higher although the startup time is reduced.
 482:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param Regulator: Specifies the regulator state in Stop mode.
 483:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 484:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
 485:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
 486:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
 487:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 488:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
 489:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction
 490:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 491:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 492:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 493:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 453              		.loc 1 493 0
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 0
 456              		@ frame_needed = 0, uses_anonymous_args = 0
 457              		@ link register save eliminated.
 458              	.LVL15:
 494:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check the parameters */
 495:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 496:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 497:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 498:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Select the regulator state in Stop mode: Set PDDS and LPSDSR bit according to PWR_Regulator va
 499:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPSDSR), Regulator);
 459              		.loc 1 499 0
 460 0000 0B4A     		ldr	r2, .L31
 461 0002 1368     		ldr	r3, [r2]
 462 0004 23F00303 		bic	r3, r3, #3
 463 0008 1843     		orrs	r0, r0, r3
 464              	.LVL16:
 465 000a 1060     		str	r0, [r2]
 500:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 501:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 502:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 466              		.loc 1 502 0
ARM GAS  /tmp/ccmFWlTF.s 			page 35


 467 000c 094A     		ldr	r2, .L31+4
 468 000e 1369     		ldr	r3, [r2, #16]
 469 0010 43F00403 		orr	r3, r3, #4
 470 0014 1361     		str	r3, [r2, #16]
 503:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 504:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Select Stop mode entry --------------------------------------------------*/
 505:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 471              		.loc 1 505 0
 472 0016 0129     		cmp	r1, #1
 473 0018 08D0     		beq	.L30
 506:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 507:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 508:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __WFI();
 509:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 510:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   else
 511:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 512:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     /* Request Wait For Event */
 513:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __SEV();
 474              		.loc 1 513 0
 475              		.syntax unified
 476              	@ 513 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 477 001a 40BF     		sev
 478              	@ 0 "" 2
 514:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __WFE();
 479              		.loc 1 514 0
 480              	@ 514 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 481 001c 20BF     		wfe
 482              	@ 0 "" 2
 515:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __WFE();
 483              		.loc 1 515 0
 484              	@ 515 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 485 001e 20BF     		wfe
 486              	@ 0 "" 2
 487              		.thumb
 488              		.syntax unified
 489              	.L29:
 516:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 517:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 518:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 490              		.loc 1 518 0
 491 0020 044A     		ldr	r2, .L31+4
 492 0022 1369     		ldr	r3, [r2, #16]
 493 0024 23F00403 		bic	r3, r3, #4
 494 0028 1361     		str	r3, [r2, #16]
 495 002a 7047     		bx	lr
 496              	.L30:
 508:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 497              		.loc 1 508 0
 498              		.syntax unified
 499              	@ 508 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 500 002c 30BF     		wfi
 501              	@ 0 "" 2
 502              		.thumb
 503              		.syntax unified
 504 002e F7E7     		b	.L29
 505              	.L32:
 506              		.align	2
ARM GAS  /tmp/ccmFWlTF.s 			page 36


 507              	.L31:
 508 0030 00700040 		.word	1073770496
 509 0034 00ED00E0 		.word	-536810240
 510              		.cfi_endproc
 511              	.LFE81:
 513              		.section	.text.HAL_PWR_EnterSTANDBYMode,"ax",%progbits
 514              		.align	1
 515              		.global	HAL_PWR_EnterSTANDBYMode
 516              		.syntax unified
 517              		.thumb
 518              		.thumb_func
 519              		.fpu softvfp
 521              	HAL_PWR_EnterSTANDBYMode:
 522              	.LFB82:
 519:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 520:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 521:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 522:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Enters Standby mode.
 523:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note  In Standby mode, all I/O pins are high impedance except for:
 524:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          - Reset pad (still available)
 525:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC
 526:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *            Alarm out, or RTC clock calibration out.
 527:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          - WKUP pin 1 (PA0) if enabled.
 528:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          - WKUP pin 2 (PC13) if enabled.
 529:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *          - WKUP pin 3 (PE6) if enabled.
 530:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 531:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 532:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 533:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 523              		.loc 1 533 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              		@ link register save eliminated.
 534:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Select Standby mode */
 535:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   SET_BIT(PWR->CR, PWR_CR_PDDS);
 528              		.loc 1 535 0
 529 0000 054A     		ldr	r2, .L34
 530 0002 1368     		ldr	r3, [r2]
 531 0004 43F00203 		orr	r3, r3, #2
 532 0008 1360     		str	r3, [r2]
 536:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 537:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 538:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 533              		.loc 1 538 0
 534 000a 044A     		ldr	r2, .L34+4
 535 000c 1369     		ldr	r3, [r2, #16]
 536 000e 43F00403 		orr	r3, r3, #4
 537 0012 1361     		str	r3, [r2, #16]
 539:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 540:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
 541:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #if defined ( __CC_ARM)
 542:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __force_stores();
 543:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** #endif
 544:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 545:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   __WFI();
 538              		.loc 1 545 0
ARM GAS  /tmp/ccmFWlTF.s 			page 37


 539              		.syntax unified
 540              	@ 545 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c" 1
 541 0014 30BF     		wfi
 542              	@ 0 "" 2
 543              		.thumb
 544              		.syntax unified
 545 0016 7047     		bx	lr
 546              	.L35:
 547              		.align	2
 548              	.L34:
 549 0018 00700040 		.word	1073770496
 550 001c 00ED00E0 		.word	-536810240
 551              		.cfi_endproc
 552              	.LFE82:
 554              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 555              		.align	1
 556              		.global	HAL_PWR_EnableSleepOnExit
 557              		.syntax unified
 558              		.thumb
 559              		.thumb_func
 560              		.fpu softvfp
 562              	HAL_PWR_EnableSleepOnExit:
 563              	.LFB83:
 546:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 547:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 548:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 549:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 550:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode.
 551:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor
 552:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 553:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *       Setting this bit is useful when the processor is expected to run only on
 554:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *       interruptions handling.
 555:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 556:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 557:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 558:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 564              		.loc 1 558 0
 565              		.cfi_startproc
 566              		@ args = 0, pretend = 0, frame = 0
 567              		@ frame_needed = 0, uses_anonymous_args = 0
 568              		@ link register save eliminated.
 559:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 560:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 569              		.loc 1 560 0
 570 0000 024A     		ldr	r2, .L37
 571 0002 1369     		ldr	r3, [r2, #16]
 572 0004 43F00203 		orr	r3, r3, #2
 573 0008 1361     		str	r3, [r2, #16]
 574 000a 7047     		bx	lr
 575              	.L38:
 576              		.align	2
 577              	.L37:
 578 000c 00ED00E0 		.word	-536810240
 579              		.cfi_endproc
 580              	.LFE83:
 582              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 583              		.align	1
ARM GAS  /tmp/ccmFWlTF.s 			page 38


 584              		.global	HAL_PWR_DisableSleepOnExit
 585              		.syntax unified
 586              		.thumb
 587              		.thumb_func
 588              		.fpu softvfp
 590              	HAL_PWR_DisableSleepOnExit:
 591              	.LFB84:
 561:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 562:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 563:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 564:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 565:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode.
 566:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor
 567:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 568:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 569:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 570:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 571:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 592              		.loc 1 571 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 0
 595              		@ frame_needed = 0, uses_anonymous_args = 0
 596              		@ link register save eliminated.
 572:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 573:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 597              		.loc 1 573 0
 598 0000 024A     		ldr	r2, .L40
 599 0002 1369     		ldr	r3, [r2, #16]
 600 0004 23F00203 		bic	r3, r3, #2
 601 0008 1361     		str	r3, [r2, #16]
 602 000a 7047     		bx	lr
 603              	.L41:
 604              		.align	2
 605              	.L40:
 606 000c 00ED00E0 		.word	-536810240
 607              		.cfi_endproc
 608              	.LFE84:
 610              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 611              		.align	1
 612              		.global	HAL_PWR_EnableSEVOnPend
 613              		.syntax unified
 614              		.thumb
 615              		.thumb_func
 616              		.fpu softvfp
 618              	HAL_PWR_EnableSEVOnPend:
 619              	.LFB85:
 574:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 575:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 576:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 577:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 578:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Enables CORTEX M3 SEVONPEND bit.
 579:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes
 580:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 581:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 582:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 583:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 584:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
ARM GAS  /tmp/ccmFWlTF.s 			page 39


 620              		.loc 1 584 0
 621              		.cfi_startproc
 622              		@ args = 0, pretend = 0, frame = 0
 623              		@ frame_needed = 0, uses_anonymous_args = 0
 624              		@ link register save eliminated.
 585:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 586:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 625              		.loc 1 586 0
 626 0000 024A     		ldr	r2, .L43
 627 0002 1369     		ldr	r3, [r2, #16]
 628 0004 43F01003 		orr	r3, r3, #16
 629 0008 1361     		str	r3, [r2, #16]
 630 000a 7047     		bx	lr
 631              	.L44:
 632              		.align	2
 633              	.L43:
 634 000c 00ED00E0 		.word	-536810240
 635              		.cfi_endproc
 636              	.LFE85:
 638              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 639              		.align	1
 640              		.global	HAL_PWR_DisableSEVOnPend
 641              		.syntax unified
 642              		.thumb
 643              		.thumb_func
 644              		.fpu softvfp
 646              	HAL_PWR_DisableSEVOnPend:
 647              	.LFB86:
 587:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 588:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 589:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 590:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 591:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief Disables CORTEX M3 SEVONPEND bit.
 592:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes
 593:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 594:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 595:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 596:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 597:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 648              		.loc 1 597 0
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 0
 651              		@ frame_needed = 0, uses_anonymous_args = 0
 652              		@ link register save eliminated.
 598:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 599:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 653              		.loc 1 599 0
 654 0000 024A     		ldr	r2, .L46
 655 0002 1369     		ldr	r3, [r2, #16]
 656 0004 23F01003 		bic	r3, r3, #16
 657 0008 1361     		str	r3, [r2, #16]
 658 000a 7047     		bx	lr
 659              	.L47:
 660              		.align	2
 661              	.L46:
 662 000c 00ED00E0 		.word	-536810240
 663              		.cfi_endproc
ARM GAS  /tmp/ccmFWlTF.s 			page 40


 664              	.LFE86:
 666              		.section	.text.HAL_PWR_PVDCallback,"ax",%progbits
 667              		.align	1
 668              		.weak	HAL_PWR_PVDCallback
 669              		.syntax unified
 670              		.thumb
 671              		.thumb_func
 672              		.fpu softvfp
 674              	HAL_PWR_PVDCallback:
 675              	.LFB88:
 600:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 601:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 602:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 603:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 604:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 605:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 606:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 607:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 608:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 609:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
 610:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 611:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check PWR exti flag */
 612:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 613:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 614:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     /* PWR PVD interrupt user callback */
 615:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     HAL_PWR_PVDCallback();
 616:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 617:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     /* Clear PWR Exti pending bit */
 618:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 619:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 620:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** }
 621:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 622:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** /**
 623:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 624:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   * @retval None
 625:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   */
 626:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** __weak void HAL_PWR_PVDCallback(void)
 627:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** {
 676              		.loc 1 627 0
 677              		.cfi_startproc
 678              		@ args = 0, pretend = 0, frame = 0
 679              		@ frame_needed = 0, uses_anonymous_args = 0
 680              		@ link register save eliminated.
 681 0000 7047     		bx	lr
 682              		.cfi_endproc
 683              	.LFE88:
 685              		.section	.text.HAL_PWR_PVD_IRQHandler,"ax",%progbits
 686              		.align	1
 687              		.global	HAL_PWR_PVD_IRQHandler
 688              		.syntax unified
 689              		.thumb
 690              		.thumb_func
 691              		.fpu softvfp
 693              	HAL_PWR_PVD_IRQHandler:
 694              	.LFB87:
 610:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check PWR exti flag */
 695              		.loc 1 610 0
ARM GAS  /tmp/ccmFWlTF.s 			page 41


 696              		.cfi_startproc
 697              		@ args = 0, pretend = 0, frame = 0
 698              		@ frame_needed = 0, uses_anonymous_args = 0
 610:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   /* Check PWR exti flag */
 699              		.loc 1 610 0
 700 0000 08B5     		push	{r3, lr}
 701              	.LCFI0:
 702              		.cfi_def_cfa_offset 8
 703              		.cfi_offset 3, -8
 704              		.cfi_offset 14, -4
 612:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   {
 705              		.loc 1 612 0
 706 0002 064B     		ldr	r3, .L53
 707 0004 5B69     		ldr	r3, [r3, #20]
 708 0006 13F4803F 		tst	r3, #65536
 709 000a 00D1     		bne	.L52
 710              	.L49:
 711 000c 08BD     		pop	{r3, pc}
 712              	.L52:
 615:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 713              		.loc 1 615 0
 714 000e FFF7FEFF 		bl	HAL_PWR_PVDCallback
 715              	.LVL17:
 618:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c ****   }
 716              		.loc 1 618 0
 717 0012 4FF48032 		mov	r2, #65536
 718 0016 014B     		ldr	r3, .L53
 719 0018 5A61     		str	r2, [r3, #20]
 620:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr.c **** 
 720              		.loc 1 620 0
 721 001a F7E7     		b	.L49
 722              	.L54:
 723              		.align	2
 724              	.L53:
 725 001c 00040140 		.word	1073808384
 726              		.cfi_endproc
 727              	.LFE87:
 729              		.text
 730              	.Letext0:
 731              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 732              		.file 4 "/usr/include/newlib/sys/_stdint.h"
 733              		.file 5 "..//Source/stm/lib/CMSIS/Include/core_cm3.h"
 734              		.file 6 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/system_stm32l1xx.h"
 735              		.file 7 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/stm32l151xba.h"
 736              		.file 8 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/stm32l1xx.h"
 737              		.file 9 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal_pwr.h"
 738              		.file 10 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal.h"
ARM GAS  /tmp/ccmFWlTF.s 			page 42


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32l1xx_hal_pwr.c
     /tmp/ccmFWlTF.s:16     .text.HAL_PWR_DeInit:0000000000000000 $t
     /tmp/ccmFWlTF.s:23     .text.HAL_PWR_DeInit:0000000000000000 HAL_PWR_DeInit
     /tmp/ccmFWlTF.s:44     .text.HAL_PWR_DeInit:0000000000000014 $d
     /tmp/ccmFWlTF.s:49     .text.HAL_PWR_EnableBkUpAccess:0000000000000000 $t
     /tmp/ccmFWlTF.s:56     .text.HAL_PWR_EnableBkUpAccess:0000000000000000 HAL_PWR_EnableBkUpAccess
     /tmp/ccmFWlTF.s:90     .text.HAL_PWR_DisableBkUpAccess:0000000000000000 $t
     /tmp/ccmFWlTF.s:97     .text.HAL_PWR_DisableBkUpAccess:0000000000000000 HAL_PWR_DisableBkUpAccess
     /tmp/ccmFWlTF.s:130    .text.HAL_PWR_ConfigPVD:0000000000000000 $t
     /tmp/ccmFWlTF.s:137    .text.HAL_PWR_ConfigPVD:0000000000000000 HAL_PWR_ConfigPVD
     /tmp/ccmFWlTF.s:212    .text.HAL_PWR_ConfigPVD:000000000000007c $d
     /tmp/ccmFWlTF.s:218    .text.HAL_PWR_EnablePVD:0000000000000000 $t
     /tmp/ccmFWlTF.s:225    .text.HAL_PWR_EnablePVD:0000000000000000 HAL_PWR_EnablePVD
     /tmp/ccmFWlTF.s:258    .text.HAL_PWR_DisablePVD:0000000000000000 $t
     /tmp/ccmFWlTF.s:265    .text.HAL_PWR_DisablePVD:0000000000000000 HAL_PWR_DisablePVD
     /tmp/ccmFWlTF.s:298    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 $t
     /tmp/ccmFWlTF.s:305    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 HAL_PWR_EnableWakeUpPin
     /tmp/ccmFWlTF.s:334    .text.HAL_PWR_EnableWakeUpPin:0000000000000014 $d
     /tmp/ccmFWlTF.s:339    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 $t
     /tmp/ccmFWlTF.s:346    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 HAL_PWR_DisableWakeUpPin
     /tmp/ccmFWlTF.s:375    .text.HAL_PWR_DisableWakeUpPin:0000000000000014 $d
     /tmp/ccmFWlTF.s:380    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 $t
     /tmp/ccmFWlTF.s:387    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 HAL_PWR_EnterSLEEPMode
     /tmp/ccmFWlTF.s:438    .text.HAL_PWR_EnterSLEEPMode:0000000000000028 $d
     /tmp/ccmFWlTF.s:444    .text.HAL_PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/ccmFWlTF.s:451    .text.HAL_PWR_EnterSTOPMode:0000000000000000 HAL_PWR_EnterSTOPMode
     /tmp/ccmFWlTF.s:508    .text.HAL_PWR_EnterSTOPMode:0000000000000030 $d
     /tmp/ccmFWlTF.s:514    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/ccmFWlTF.s:521    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 HAL_PWR_EnterSTANDBYMode
     /tmp/ccmFWlTF.s:549    .text.HAL_PWR_EnterSTANDBYMode:0000000000000018 $d
     /tmp/ccmFWlTF.s:555    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 $t
     /tmp/ccmFWlTF.s:562    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 HAL_PWR_EnableSleepOnExit
     /tmp/ccmFWlTF.s:578    .text.HAL_PWR_EnableSleepOnExit:000000000000000c $d
     /tmp/ccmFWlTF.s:583    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 $t
     /tmp/ccmFWlTF.s:590    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 HAL_PWR_DisableSleepOnExit
     /tmp/ccmFWlTF.s:606    .text.HAL_PWR_DisableSleepOnExit:000000000000000c $d
     /tmp/ccmFWlTF.s:611    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 $t
     /tmp/ccmFWlTF.s:618    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 HAL_PWR_EnableSEVOnPend
     /tmp/ccmFWlTF.s:634    .text.HAL_PWR_EnableSEVOnPend:000000000000000c $d
     /tmp/ccmFWlTF.s:639    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 $t
     /tmp/ccmFWlTF.s:646    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 HAL_PWR_DisableSEVOnPend
     /tmp/ccmFWlTF.s:662    .text.HAL_PWR_DisableSEVOnPend:000000000000000c $d
     /tmp/ccmFWlTF.s:667    .text.HAL_PWR_PVDCallback:0000000000000000 $t
     /tmp/ccmFWlTF.s:674    .text.HAL_PWR_PVDCallback:0000000000000000 HAL_PWR_PVDCallback
     /tmp/ccmFWlTF.s:686    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 $t
     /tmp/ccmFWlTF.s:693    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 HAL_PWR_PVD_IRQHandler
     /tmp/ccmFWlTF.s:725    .text.HAL_PWR_PVD_IRQHandler:000000000000001c $d
                     .debug_frame:0000000000000010 $d

NO UNDEFINED SYMBOLS
