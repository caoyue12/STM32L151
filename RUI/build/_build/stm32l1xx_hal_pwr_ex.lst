ARM GAS  /tmp/cc3XEkSG.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32l1xx_hal_pwr_ex.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.HAL_PWREx_GetVoltageRange,"ax",%progbits
  16              		.align	1
  17              		.global	HAL_PWREx_GetVoltageRange
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	HAL_PWREx_GetVoltageRange:
  24              	.LFB72:
  25              		.file 1 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c"
   1:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
   2:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   ******************************************************************************
   3:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @file    stm32l1xx_hal_pwr_ex.c
   4:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @author  MCD Application Team
   5:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief   Extended PWR HAL module driver.
   6:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *          This file provides firmware functions to manage the following
   7:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   8:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *           + Extended Initialization and de-initialization functions
   9:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *           + Extended Peripheral Control functions
  10:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *
  11:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   ******************************************************************************
  12:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @attention
  13:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *
  14:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
  15:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * All rights reserved.</center></h2>
  16:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *
  17:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  18:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * the "License"; You may not use this file except in compliance with the
  19:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * License. You may obtain a copy of the License at:
  20:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *                        opensource.org/licenses/BSD-3-Clause
  21:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *
  22:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   ******************************************************************************
  23:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  24:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  25:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Includes ------------------------------------------------------------------*/
  26:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** #include "stm32l1xx_hal.h"
  27:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  28:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /** @addtogroup STM32L1xx_HAL_Driver
  29:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @{
  30:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  31:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  32:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /** @defgroup PWREx PWREx
  33:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief    PWR HAL module driver
ARM GAS  /tmp/cc3XEkSG.s 			page 2


  34:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @{
  35:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  36:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  37:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** #ifdef HAL_PWR_MODULE_ENABLED
  38:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  39:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Private typedef -----------------------------------------------------------*/
  40:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Private define ------------------------------------------------------------*/
  41:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Private macro -------------------------------------------------------------*/
  42:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Private variables ---------------------------------------------------------*/
  43:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Private function prototypes -----------------------------------------------*/
  44:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /* Private functions ---------------------------------------------------------*/
  45:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  46:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /** @defgroup PWREx_Exported_Functions PWREx Exported Functions
  47:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @{
  48:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  49:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  50:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended Features Functions
  51:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief    Low Power modes configuration functions
  52:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *
  53:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** @verbatim
  54:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  55:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****  ===============================================================================
  56:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****                  ##### Peripheral extended features functions #####
  57:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****  ===============================================================================
  58:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** @endverbatim
  59:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @{
  60:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  61:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  62:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
  63:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief Return Voltage Scaling Range.
  64:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or PWR_REGULA
  65:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  66:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** uint32_t HAL_PWREx_GetVoltageRange(void)
  67:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
  26              		.loc 1 67 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  68:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   return  (PWR->CR & PWR_CR_VOS);
  31              		.loc 1 68 0
  32 0000 024B     		ldr	r3, .L2
  33 0002 1868     		ldr	r0, [r3]
  69:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
  34              		.loc 1 69 0
  35 0004 00F4C050 		and	r0, r0, #6144
  36 0008 7047     		bx	lr
  37              	.L3:
  38 000a 00BF     		.align	2
  39              	.L2:
  40 000c 00700040 		.word	1073770496
  41              		.cfi_endproc
  42              	.LFE72:
  44              		.section	.text.HAL_PWREx_EnableFastWakeUp,"ax",%progbits
  45              		.align	1
  46              		.global	HAL_PWREx_EnableFastWakeUp
  47              		.syntax unified
ARM GAS  /tmp/cc3XEkSG.s 			page 3


  48              		.thumb
  49              		.thumb_func
  50              		.fpu softvfp
  52              	HAL_PWREx_EnableFastWakeUp:
  53              	.LFB73:
  70:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  71:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  72:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
  73:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief  Enables the Fast WakeUp from Ultra Low Power mode.
  74:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @note   This bit works in conjunction with ULP bit.
  75:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *         Means, when ULP = 1 and FWU = 1 :VREFINT startup time is ignored when
  76:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *         exiting from low power mode.
  77:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval None
  78:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  79:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** void HAL_PWREx_EnableFastWakeUp(void)
  80:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
  54              		.loc 1 80 0
  55              		.cfi_startproc
  56              		@ args = 0, pretend = 0, frame = 0
  57              		@ frame_needed = 0, uses_anonymous_args = 0
  58              		@ link register save eliminated.
  59              	.LVL0:
  60              	.LBB18:
  61              	.LBB19:
  62              		.file 2 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h"
   1:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /*
   8:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  10:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  12:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  16:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  18:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
  24:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  25:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  28:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
ARM GAS  /tmp/cc3XEkSG.s 			page 4


  33:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  34:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  38:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  39:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  43:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  46:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  49:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  55:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  58:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  61:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  64:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  67:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  70:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  78:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  86:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
ARM GAS  /tmp/cc3XEkSG.s 			page 5


  90:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  94:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 102:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 110:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 113:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 116:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 117:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 118:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   @{
 122:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 123:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 124:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 125:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 129:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 131:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 133:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 134:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 135:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 136:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 140:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 142:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 144:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 145:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 146:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/cc3XEkSG.s 			page 6


 147:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 151:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 153:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 155:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 158:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 159:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 160:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 162:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 166:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 168:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 170:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 173:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 174:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 175:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 176:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 177:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 181:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 183:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 185:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 186:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 187:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 189:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 193:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 195:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 197:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 198:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 199:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 200:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 201:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
ARM GAS  /tmp/cc3XEkSG.s 			page 7


 204:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 205:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 207:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 209:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 212:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 213:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 214:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 215:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 219:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 221:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 223:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 226:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 227:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 228:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 229:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 233:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 235:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 237:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 240:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 241:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 242:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 243:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 247:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 249:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 251:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 254:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 255:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 256:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 258:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
ARM GAS  /tmp/cc3XEkSG.s 			page 8


 261:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 262:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 264:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 266:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 269:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 270:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 271:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 272:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 273:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 277:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 279:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 281:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 282:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 283:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 285:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 289:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 291:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 293:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 294:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 295:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 296:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 297:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 301:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 303:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 305:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 308:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 309:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 310:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 312:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 316:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/cc3XEkSG.s 			page 9


 318:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 320:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 323:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 324:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 325:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 326:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 327:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 331:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 333:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 335:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 336:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 337:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 339:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 343:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 345:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 347:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 348:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 349:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 350:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 352:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 356:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 358:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 360:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 363:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 364:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 365:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 366:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 370:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 372:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 374:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/cc3XEkSG.s 			page 10


 375:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 376:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 377:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 378:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 382:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 384:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 386:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 389:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 390:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 391:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 393:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 397:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 399:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 401:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 404:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 405:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 406:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 407:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 408:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 412:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 414:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 416:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 417:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 418:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 420:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 424:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 426:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 428:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 429:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 430:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 431:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
ARM GAS  /tmp/cc3XEkSG.s 			page 11


 432:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 435:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 439:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 441:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 443:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 444:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 445:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 446:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 450:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 452:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 454:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 455:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 456:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 457:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 461:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 463:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 465:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 468:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 469:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 470:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 472:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 476:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 478:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 480:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 483:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 484:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 485:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 486:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 487:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
ARM GAS  /tmp/cc3XEkSG.s 			page 12


 489:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 491:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 493:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 495:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 496:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 497:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 499:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 503:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 505:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 507:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 508:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 509:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 510:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 511:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 516:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 518:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 520:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 521:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 522:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 523:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 527:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 529:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 531:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 534:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 535:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 536:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 538:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 542:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 544:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cc3XEkSG.s 			page 13


 546:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 549:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 550:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 551:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 552:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 553:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 557:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 559:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 561:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 562:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 563:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 565:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 569:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 571:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 573:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 574:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 575:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 579:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 580:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 583:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 584:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   
 589:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 592:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 594:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 599:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/cc3XEkSG.s 			page 14


 603:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 604:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 605:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 607:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 611:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 614:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 616:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 620:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 624:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 625:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 626:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 627:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 628:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 629:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   
 634:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 637:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 639:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 644:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 646:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 647:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 648:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 649:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 651:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 655:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 658:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/cc3XEkSG.s 			page 15


 660:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 664:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 666:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 667:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 668:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 669:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 670:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 671:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 676:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 679:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 681:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 686:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 690:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 691:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 692:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 693:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 695:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 699:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 702:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 704:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 708:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 712:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 713:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 714:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 715:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 716:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/cc3XEkSG.s 			page 16


 717:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 722:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 725:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 727:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 732:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 734:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 735:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 736:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 737:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 739:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 743:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 746:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 748:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 752:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 754:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 755:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 756:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 757:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 760:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 761:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 762:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 766:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 768:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
ARM GAS  /tmp/cc3XEkSG.s 			page 17


 774:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 776:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 778:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 781:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 782:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 784:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 785:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 786:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 787:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 788:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 792:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 794:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 802:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 804:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 805:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 807:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 808:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 809:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 810:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 812:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 813:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   @{
 817:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** */
 818:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 819:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 827:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/cc3XEkSG.s 			page 18


 831:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 832:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 833:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 836:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 838:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 839:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 842:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 844:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 845:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 846:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 850:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 852:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 853:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 854:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 857:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 859:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 860:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 861:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 866:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 868:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 870:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 871:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 872:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 873:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 877:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 879:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 881:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 882:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 883:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 884:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/cc3XEkSG.s 			page 19


 888:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 890:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 892:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 893:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 894:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 895:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 900:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 902:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 905:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 907:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 910:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 911:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 912:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 913:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 914:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 919:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 921:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 923:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 926:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 927:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 928:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 929:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 934:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 936:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 939:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 941:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 944:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/cc3XEkSG.s 			page 20


 945:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 946:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 947:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 948:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 954:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 956:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   {
 959:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     return op1;
 960:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   }
 961:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 963:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 964:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 965:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 966:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 972:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 974:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 975:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 976:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 981:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 983:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 985:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
  63              		.loc 2 988 0
  64 0000 4FF48063 		mov	r3, #1024
  65              		.syntax unified
  66              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
  67 0004 93FAA3F3 		rbit r3, r3
  68              	@ 0 "" 2
  69              	.LVL1:
  70              		.thumb
  71              		.syntax unified
  72              	.LBE19:
  73              	.LBE18:
  81:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   /* Enable the fast wake up */
  82:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_FWU_BB = (uint32_t)ENABLE;
ARM GAS  /tmp/cc3XEkSG.s 			page 21


  74              		.loc 1 82 0
  75 0008 B3FA83F3 		clz	r3, r3
  76 000c 9B00     		lsls	r3, r3, #2
  77 000e 03F18443 		add	r3, r3, #1107296256
  78 0012 03F56023 		add	r3, r3, #917504
  79 0016 0122     		movs	r2, #1
  80 0018 1A60     		str	r2, [r3]
  81 001a 7047     		bx	lr
  82              		.cfi_endproc
  83              	.LFE73:
  85              		.section	.text.HAL_PWREx_DisableFastWakeUp,"ax",%progbits
  86              		.align	1
  87              		.global	HAL_PWREx_DisableFastWakeUp
  88              		.syntax unified
  89              		.thumb
  90              		.thumb_func
  91              		.fpu softvfp
  93              	HAL_PWREx_DisableFastWakeUp:
  94              	.LFB74:
  83:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
  84:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  85:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
  86:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief  Disables the Fast WakeUp from Ultra Low Power mode.
  87:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval None
  88:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  89:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** void HAL_PWREx_DisableFastWakeUp(void)
  90:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
  95              		.loc 1 90 0
  96              		.cfi_startproc
  97              		@ args = 0, pretend = 0, frame = 0
  98              		@ frame_needed = 0, uses_anonymous_args = 0
  99              		@ link register save eliminated.
 100              	.LVL2:
 101              	.LBB20:
 102              	.LBB21:
 103              		.loc 2 988 0
 104 0000 4FF48063 		mov	r3, #1024
 105              		.syntax unified
 106              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 107 0004 93FAA3F3 		rbit r3, r3
 108              	@ 0 "" 2
 109              	.LVL3:
 110              		.thumb
 111              		.syntax unified
 112              	.LBE21:
 113              	.LBE20:
  91:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   /* Disable the fast wake up */
  92:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_FWU_BB = (uint32_t)DISABLE;
 114              		.loc 1 92 0
 115 0008 B3FA83F3 		clz	r3, r3
 116 000c 9B00     		lsls	r3, r3, #2
 117 000e 03F18443 		add	r3, r3, #1107296256
 118 0012 03F56023 		add	r3, r3, #917504
 119 0016 0022     		movs	r2, #0
 120 0018 1A60     		str	r2, [r3]
 121 001a 7047     		bx	lr
 122              		.cfi_endproc
ARM GAS  /tmp/cc3XEkSG.s 			page 22


 123              	.LFE74:
 125              		.section	.text.HAL_PWREx_EnableUltraLowPower,"ax",%progbits
 126              		.align	1
 127              		.global	HAL_PWREx_EnableUltraLowPower
 128              		.syntax unified
 129              		.thumb
 130              		.thumb_func
 131              		.fpu softvfp
 133              	HAL_PWREx_EnableUltraLowPower:
 134              	.LFB75:
  93:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
  94:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
  95:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
  96:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief  Enables the Ultra Low Power mode
  97:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval None
  98:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
  99:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** void HAL_PWREx_EnableUltraLowPower(void)
 100:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
 135              		.loc 1 100 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140              	.LVL4:
 141              	.LBB22:
 142              	.LBB23:
 143              		.loc 2 988 0
 144 0000 4FF40073 		mov	r3, #512
 145              		.syntax unified
 146              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 147 0004 93FAA3F3 		rbit r3, r3
 148              	@ 0 "" 2
 149              	.LVL5:
 150              		.thumb
 151              		.syntax unified
 152              	.LBE23:
 153              	.LBE22:
 101:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   /* Enable the Ultra Low Power mode */
 102:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_ULP_BB = (uint32_t)ENABLE;
 154              		.loc 1 102 0
 155 0008 B3FA83F3 		clz	r3, r3
 156 000c 9B00     		lsls	r3, r3, #2
 157 000e 03F18443 		add	r3, r3, #1107296256
 158 0012 03F56023 		add	r3, r3, #917504
 159 0016 0122     		movs	r2, #1
 160 0018 1A60     		str	r2, [r3]
 161 001a 7047     		bx	lr
 162              		.cfi_endproc
 163              	.LFE75:
 165              		.section	.text.HAL_PWREx_DisableUltraLowPower,"ax",%progbits
 166              		.align	1
 167              		.global	HAL_PWREx_DisableUltraLowPower
 168              		.syntax unified
 169              		.thumb
 170              		.thumb_func
 171              		.fpu softvfp
 173              	HAL_PWREx_DisableUltraLowPower:
ARM GAS  /tmp/cc3XEkSG.s 			page 23


 174              	.LFB76:
 103:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
 104:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
 105:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
 106:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief  Disables the Ultra Low Power mode
 107:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval None
 108:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
 109:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** void HAL_PWREx_DisableUltraLowPower(void)
 110:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
 175              		.loc 1 110 0
 176              		.cfi_startproc
 177              		@ args = 0, pretend = 0, frame = 0
 178              		@ frame_needed = 0, uses_anonymous_args = 0
 179              		@ link register save eliminated.
 180              	.LVL6:
 181              	.LBB24:
 182              	.LBB25:
 183              		.loc 2 988 0
 184 0000 4FF40073 		mov	r3, #512
 185              		.syntax unified
 186              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 187 0004 93FAA3F3 		rbit r3, r3
 188              	@ 0 "" 2
 189              	.LVL7:
 190              		.thumb
 191              		.syntax unified
 192              	.LBE25:
 193              	.LBE24:
 111:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   /* Disable the Ultra Low Power mode */
 112:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_ULP_BB = (uint32_t)DISABLE;
 194              		.loc 1 112 0
 195 0008 B3FA83F3 		clz	r3, r3
 196 000c 9B00     		lsls	r3, r3, #2
 197 000e 03F18443 		add	r3, r3, #1107296256
 198 0012 03F56023 		add	r3, r3, #917504
 199 0016 0022     		movs	r2, #0
 200 0018 1A60     		str	r2, [r3]
 201 001a 7047     		bx	lr
 202              		.cfi_endproc
 203              	.LFE76:
 205              		.section	.text.HAL_PWREx_EnableLowPowerRunMode,"ax",%progbits
 206              		.align	1
 207              		.global	HAL_PWREx_EnableLowPowerRunMode
 208              		.syntax unified
 209              		.thumb
 210              		.thumb_func
 211              		.fpu softvfp
 213              	HAL_PWREx_EnableLowPowerRunMode:
 214              	.LFB77:
 113:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
 114:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
 115:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
 116:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief  Enters the Low Power Run mode.
 117:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @note   Low power run mode can only be entered when VCORE is in range 2.
 118:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *         In addition, the dynamic voltage scaling must not be used when Low
 119:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *         power run mode is selected. Only Stop and Sleep modes with regulator
 120:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *         configured in Low power mode is allowed when Low power run mode is
ARM GAS  /tmp/cc3XEkSG.s 			page 24


 121:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *         selected.
 122:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @note   In Low power run mode, all I/O pins keep the same state as in Run mode.
 123:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval None
 124:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
 125:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** void HAL_PWREx_EnableLowPowerRunMode(void)
 126:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
 215              		.loc 1 126 0
 216              		.cfi_startproc
 217              		@ args = 0, pretend = 0, frame = 0
 218              		@ frame_needed = 0, uses_anonymous_args = 0
 219              		@ link register save eliminated.
 220              	.LVL8:
 221              	.LBB26:
 222              	.LBB27:
 223              		.loc 2 988 0
 224 0000 0122     		movs	r2, #1
 225              		.syntax unified
 226              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 227 0002 92FAA2F3 		rbit r3, r2
 228              	@ 0 "" 2
 229              	.LVL9:
 230              		.thumb
 231              		.syntax unified
 232              	.LBE27:
 233              	.LBE26:
 127:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   /* Enters the Low Power Run mode */
 128:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_LPSDSR_BB = (uint32_t)ENABLE;
 234              		.loc 1 128 0
 235 0006 B3FA83F3 		clz	r3, r3
 236 000a 9B00     		lsls	r3, r3, #2
 237 000c 03F18443 		add	r3, r3, #1107296256
 238 0010 03F56023 		add	r3, r3, #917504
 239 0014 1A60     		str	r2, [r3]
 240              	.LVL10:
 241              	.LBB28:
 242              	.LBB29:
 243              		.loc 2 988 0
 244 0016 4FF48043 		mov	r3, #16384
 245              		.syntax unified
 246              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 247 001a 93FAA3F3 		rbit r3, r3
 248              	@ 0 "" 2
 249              	.LVL11:
 250              		.thumb
 251              		.syntax unified
 252              	.LBE29:
 253              	.LBE28:
 129:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_LPRUN_BB  = (uint32_t)ENABLE;
 254              		.loc 1 129 0
 255 001e B3FA83F3 		clz	r3, r3
 256 0022 9B00     		lsls	r3, r3, #2
 257 0024 03F18443 		add	r3, r3, #1107296256
 258 0028 03F56023 		add	r3, r3, #917504
 259 002c 1A60     		str	r2, [r3]
 260 002e 7047     		bx	lr
 261              		.cfi_endproc
 262              	.LFE77:
ARM GAS  /tmp/cc3XEkSG.s 			page 25


 264              		.section	.text.HAL_PWREx_DisableLowPowerRunMode,"ax",%progbits
 265              		.align	1
 266              		.global	HAL_PWREx_DisableLowPowerRunMode
 267              		.syntax unified
 268              		.thumb
 269              		.thumb_func
 270              		.fpu softvfp
 272              	HAL_PWREx_DisableLowPowerRunMode:
 273              	.LFB78:
 130:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
 131:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** 
 132:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** /**
 133:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @brief  Exits the Low Power Run mode.
 134:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   * @retval None
 135:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   */
 136:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
 137:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** {
 274              		.loc 1 137 0
 275              		.cfi_startproc
 276              		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279              	.LVL12:
 280              	.LBB30:
 281              	.LBB31:
 282              		.loc 2 988 0
 283 0000 4FF48043 		mov	r3, #16384
 284              		.syntax unified
 285              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 286 0004 93FAA3F3 		rbit r3, r3
 287              	@ 0 "" 2
 288              	.LVL13:
 289              		.thumb
 290              		.syntax unified
 291              	.LBE31:
 292              	.LBE30:
 138:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   /* Exits the Low Power Run mode */
 139:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_LPRUN_BB  = (uint32_t)DISABLE;
 293              		.loc 1 139 0
 294 0008 B3FA83F3 		clz	r3, r3
 295 000c 9B00     		lsls	r3, r3, #2
 296 000e 03F18443 		add	r3, r3, #1107296256
 297 0012 03F56023 		add	r3, r3, #917504
 298 0016 0020     		movs	r0, #0
 299 0018 1860     		str	r0, [r3]
 300              	.LVL14:
 301              	.LBB32:
 302              	.LBB33:
 303              		.loc 2 988 0
 304 001a 0123     		movs	r3, #1
 305              		.syntax unified
 306              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 307 001c 93FAA3F3 		rbit r3, r3
 308              	@ 0 "" 2
 309              	.LVL15:
 310              		.thumb
 311              		.syntax unified
ARM GAS  /tmp/cc3XEkSG.s 			page 26


 312              	.LBE33:
 313              	.LBE32:
 140:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   *(__IO uint32_t *) CR_LPSDSR_BB = (uint32_t)DISABLE;
 314              		.loc 1 140 0
 315 0020 B3FA83F3 		clz	r3, r3
 316 0024 9B00     		lsls	r3, r3, #2
 317 0026 03F18443 		add	r3, r3, #1107296256
 318 002a 03F56023 		add	r3, r3, #917504
 319 002e 1860     		str	r0, [r3]
 141:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c ****   return HAL_OK;
 142:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_pwr_ex.c **** }
 320              		.loc 1 142 0
 321 0030 7047     		bx	lr
 322              		.cfi_endproc
 323              	.LFE78:
 325              		.text
 326              	.Letext0:
 327              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 328              		.file 4 "/usr/include/newlib/sys/_stdint.h"
 329              		.file 5 "..//Source/stm/lib/CMSIS/Include/core_cm3.h"
 330              		.file 6 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/system_stm32l1xx.h"
 331              		.file 7 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/stm32l151xba.h"
 332              		.file 8 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/stm32l1xx.h"
 333              		.file 9 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal_def.h"
 334              		.file 10 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal.h"
ARM GAS  /tmp/cc3XEkSG.s 			page 27


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32l1xx_hal_pwr_ex.c
     /tmp/cc3XEkSG.s:16     .text.HAL_PWREx_GetVoltageRange:0000000000000000 $t
     /tmp/cc3XEkSG.s:23     .text.HAL_PWREx_GetVoltageRange:0000000000000000 HAL_PWREx_GetVoltageRange
     /tmp/cc3XEkSG.s:40     .text.HAL_PWREx_GetVoltageRange:000000000000000c $d
     /tmp/cc3XEkSG.s:45     .text.HAL_PWREx_EnableFastWakeUp:0000000000000000 $t
     /tmp/cc3XEkSG.s:52     .text.HAL_PWREx_EnableFastWakeUp:0000000000000000 HAL_PWREx_EnableFastWakeUp
     /tmp/cc3XEkSG.s:86     .text.HAL_PWREx_DisableFastWakeUp:0000000000000000 $t
     /tmp/cc3XEkSG.s:93     .text.HAL_PWREx_DisableFastWakeUp:0000000000000000 HAL_PWREx_DisableFastWakeUp
     /tmp/cc3XEkSG.s:126    .text.HAL_PWREx_EnableUltraLowPower:0000000000000000 $t
     /tmp/cc3XEkSG.s:133    .text.HAL_PWREx_EnableUltraLowPower:0000000000000000 HAL_PWREx_EnableUltraLowPower
     /tmp/cc3XEkSG.s:166    .text.HAL_PWREx_DisableUltraLowPower:0000000000000000 $t
     /tmp/cc3XEkSG.s:173    .text.HAL_PWREx_DisableUltraLowPower:0000000000000000 HAL_PWREx_DisableUltraLowPower
     /tmp/cc3XEkSG.s:206    .text.HAL_PWREx_EnableLowPowerRunMode:0000000000000000 $t
     /tmp/cc3XEkSG.s:213    .text.HAL_PWREx_EnableLowPowerRunMode:0000000000000000 HAL_PWREx_EnableLowPowerRunMode
     /tmp/cc3XEkSG.s:265    .text.HAL_PWREx_DisableLowPowerRunMode:0000000000000000 $t
     /tmp/cc3XEkSG.s:272    .text.HAL_PWREx_DisableLowPowerRunMode:0000000000000000 HAL_PWREx_DisableLowPowerRunMode
                     .debug_frame:0000000000000010 $d

NO UNDEFINED SYMBOLS
