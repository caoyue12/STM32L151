ARM GAS  /tmp/ccZBs9AV.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32l1xx_hal_adc_ex.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.HAL_ADCEx_InjectedStart,"ax",%progbits
  16              		.align	1
  17              		.global	HAL_ADCEx_InjectedStart
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	HAL_ADCEx_InjectedStart:
  24              	.LFB72:
  25              		.file 1 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c"
   1:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
   2:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   ******************************************************************************
   3:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @file    stm32l1xx_hal_adc_ex.c
   4:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @author  MCD Application Team
   5:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief   This file provides firmware functions to manage the following 
   6:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          functionalities of the Analog to Digital Convertor (ADC)
   7:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          peripheral:
   8:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *           + Operation functions
   9:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *             ++ Start, stop, get result of conversions of injected
  10:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *                group, using 2 possible modes: polling, interruption.
  11:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *           + Control functions
  12:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *             ++ Channels configuration on injected group
  13:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          Other functions (generic functions) are available in file 
  14:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          "stm32l1xx_hal_adc.c".
  15:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *
  16:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   @verbatim
  17:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   [..] 
  18:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   (@) Sections "ADC peripheral features" and "How to use this driver" are
  19:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       available in file of generic functions "stm32l1xx_hal_adc.c".
  20:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   [..]
  21:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   @endverbatim
  22:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   ******************************************************************************
  23:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @attention
  24:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *
  25:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
  26:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * All rights reserved.</center></h2>
  27:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *
  28:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  29:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * the "License"; You may not use this file except in compliance with the
  30:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * License. You may obtain a copy of the License at:
  31:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *                        opensource.org/licenses/BSD-3-Clause
  32:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *
  33:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   ******************************************************************************
ARM GAS  /tmp/ccZBs9AV.s 			page 2


  34:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
  35:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  36:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Includes ------------------------------------------------------------------*/
  37:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** #include "stm32l1xx_hal.h"
  38:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  39:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /** @addtogroup STM32L1xx_HAL_Driver
  40:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @{
  41:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
  42:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  43:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /** @defgroup ADCEx ADCEx
  44:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief ADC Extension HAL module driver
  45:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @{
  46:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
  47:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  48:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** #ifdef HAL_ADC_MODULE_ENABLED
  49:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  50:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Private typedef -----------------------------------------------------------*/
  51:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Private define ------------------------------------------------------------*/
  52:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /** @defgroup ADCEx_Private_Constants ADCEx Private Constants
  53:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @{
  54:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
  55:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  56:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* ADC conversion cycles (unit: ADC clock cycles)                           */
  57:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* (selected sampling time + conversion time of 12 ADC clock cycles, with   */
  58:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* resolution 12 bits)                                                      */
  59:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_4CYCLE5   ( 16U)
  60:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_9CYCLES   ( 21U)
  61:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_16CYCLES  ( 28U)
  62:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_24CYCLES  ( 36U)
  63:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_48CYCLES  ( 60U)
  64:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_96CYCLES  (108U)
  65:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_192CYCLES (204U)
  66:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_CONVERSIONCLOCKCYCLES_SAMPLETIME_384CYCLES (396U)
  67:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  68:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Delay for temperature sensor stabilization time.                         */
  69:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
  70:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Unit: us                                                                 */
  71:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   #define ADC_TEMPSENSOR_DELAY_US         (10U)
  72:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  73:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
  74:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @}
  75:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
  76:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  77:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Private macro -------------------------------------------------------------*/
  78:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Private variables ---------------------------------------------------------*/
  79:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Private function prototypes -----------------------------------------------*/
  80:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /* Private functions ---------------------------------------------------------*/
  81:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  82:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /** @defgroup ADCEx_Exported_Functions ADCEx Exported Functions
  83:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @{
  84:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
  85:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
  86:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /** @defgroup ADCEx_Exported_Functions_Group1 ADC Extended IO operation functions
  87:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****  *  @brief    ADC Extended Input and Output operation functions
  88:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****  *
  89:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** @verbatim
  90:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****  ===============================================================================
ARM GAS  /tmp/ccZBs9AV.s 			page 3


  91:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       ##### IO operation functions #####
  92:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****  ===============================================================================
  93:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     [..]  This section provides functions allowing to:
  94:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Start conversion of injected group.
  95:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Stop conversion of injected group.
  96:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Poll for conversion complete on injected group.
  97:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Get result of injected channel conversion.
  98:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Start conversion of injected group and enable interruptions.
  99:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Stop conversion of injected group and disable interruptions.
 100:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       
 101:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** @endverbatim
 102:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @{
 103:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 104:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 105:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 106:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Enables ADC, starts conversion of injected group.
 107:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         Interruptions enabled in this function: None.
 108:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 109:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval HAL status
 110:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 111:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
 112:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
  26              		.loc 1 112 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
 113:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 114:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 115:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 116:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 117:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 118:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process locked */
 119:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_LOCK(hadc);
  31              		.loc 1 119 0
  32 0000 90F84830 		ldrb	r3, [r0, #72]	@ zero_extendqisi2
  33 0004 012B     		cmp	r3, #1
  34 0006 02D1     		bne	.L9
  35 0008 0223     		movs	r3, #2
 120:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 121:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Enable the ADC peripheral */
 122:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   tmp_hal_status = ADC_Enable(hadc);
 123:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 124:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Start conversion if ADC is effectively enabled */
 125:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (tmp_hal_status == HAL_OK)
 126:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 127:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Set ADC state                                                          */
 128:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* - Clear state bitfield related to injected group conversion results    */
 129:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* - Set state bitfield related to injected operation                     */
 130:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     ADC_STATE_CLR_SET(hadc->State,
 131:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
 132:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       HAL_ADC_STATE_INJ_BUSY);
 133:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 134:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Check if a regular conversion is ongoing */
 135:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Note: On this device, there is no ADC error code fields related to     */
 136:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /*       conversions on group injected only. In case of conversion on     */
 137:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /*       going on group regular, no error code is reset.                  */
ARM GAS  /tmp/ccZBs9AV.s 			page 4


 138:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 139:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 140:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Reset ADC all error code fields */
 141:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       ADC_CLEAR_ERRORCODE(hadc);
 142:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 143:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 144:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Process unlocked */
 145:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Unlock before starting ADC conversions: in case of potential           */
 146:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* interruption, to let the process to ADC IRQ Handler.                   */
 147:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     __HAL_UNLOCK(hadc);
 148:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 149:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Clear injected group conversion flag */
 150:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* (To ensure of no unknown state from potential previous ADC operations) */
 151:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
 152:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 153:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Enable conversion of injected group.                                   */
 154:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If software start has been selected, conversion starts immediately.    */
 155:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If external trigger has been selected, conversion will start at next   */
 156:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* trigger event.                                                         */
 157:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If automatic injected conversion is enabled, conversion will start     */
 158:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* after next regular group conversion.                                   */
 159:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (ADC_IS_SOFTWARE_START_INJECTED(hadc)              && 
 160:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
 161:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 162:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Enable ADC software conversion for injected channels */
 163:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       SET_BIT(hadc->Instance->CR2, ADC_CR2_JSWSTART);
 164:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 165:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 166:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 167:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return function status */
 168:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return tmp_hal_status;
 169:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
  36              		.loc 1 169 0
  37 000a 1846     		mov	r0, r3
  38              	.LVL1:
  39 000c 7047     		bx	lr
  40              	.LVL2:
  41              	.L9:
 112:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  42              		.loc 1 112 0 discriminator 2
  43 000e 10B5     		push	{r4, lr}
  44              	.LCFI0:
  45              		.cfi_def_cfa_offset 8
  46              		.cfi_offset 4, -8
  47              		.cfi_offset 14, -4
  48 0010 0446     		mov	r4, r0
 119:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
  49              		.loc 1 119 0 discriminator 2
  50 0012 0123     		movs	r3, #1
  51 0014 80F84830 		strb	r3, [r0, #72]
 122:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
  52              		.loc 1 122 0 discriminator 2
  53 0018 FFF7FEFF 		bl	ADC_Enable
  54              	.LVL3:
 125:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
  55              		.loc 1 125 0 discriminator 2
  56 001c 0346     		mov	r3, r0
ARM GAS  /tmp/ccZBs9AV.s 			page 5


  57 001e 08BB     		cbnz	r0, .L2
 130:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
  58              		.loc 1 130 0
  59 0020 E26C     		ldr	r2, [r4, #76]
  60 0022 22F44052 		bic	r2, r2, #12288
  61 0026 22F00102 		bic	r2, r2, #1
  62 002a 42F48052 		orr	r2, r2, #4096
  63 002e E264     		str	r2, [r4, #76]
 138:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
  64              		.loc 1 138 0
  65 0030 E26C     		ldr	r2, [r4, #76]
  66 0032 12F4807F 		tst	r2, #256
  67 0036 01D1     		bne	.L3
 141:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
  68              		.loc 1 141 0
  69 0038 0022     		movs	r2, #0
  70 003a 2265     		str	r2, [r4, #80]
  71              	.L3:
 147:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
  72              		.loc 1 147 0
  73 003c 0022     		movs	r2, #0
  74 003e 84F84820 		strb	r2, [r4, #72]
 151:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
  75              		.loc 1 151 0
  76 0042 2268     		ldr	r2, [r4]
  77 0044 6FF00401 		mvn	r1, #4
  78 0048 1160     		str	r1, [r2]
 159:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
  79              		.loc 1 159 0
  80 004a 2268     		ldr	r2, [r4]
  81 004c 9168     		ldr	r1, [r2, #8]
  82 004e 11F4401F 		tst	r1, #3145728
  83 0052 07D1     		bne	.L2
 160:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
  84              		.loc 1 160 0 discriminator 1
  85 0054 5168     		ldr	r1, [r2, #4]
 159:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
  86              		.loc 1 159 0 discriminator 1
  87 0056 11F4806F 		tst	r1, #1024
  88 005a 03D1     		bne	.L2
 163:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
  89              		.loc 1 163 0
  90 005c 9168     		ldr	r1, [r2, #8]
  91 005e 41F48001 		orr	r1, r1, #4194304
  92 0062 9160     		str	r1, [r2, #8]
  93              	.L2:
  94              		.loc 1 169 0
  95 0064 1846     		mov	r0, r3
  96              	.LVL4:
  97 0066 10BD     		pop	{r4, pc}
  98              		.cfi_endproc
  99              	.LFE72:
 101              		.section	.text.HAL_ADCEx_InjectedStop,"ax",%progbits
 102              		.align	1
 103              		.global	HAL_ADCEx_InjectedStop
 104              		.syntax unified
 105              		.thumb
ARM GAS  /tmp/ccZBs9AV.s 			page 6


 106              		.thumb_func
 107              		.fpu softvfp
 109              	HAL_ADCEx_InjectedStop:
 110              	.LFB73:
 170:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 171:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 172:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Stop conversion of injected channels. Disable ADC peripheral if
 173:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         no regular conversion is on going.
 174:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   If ADC must be disabled and if conversion is on going on 
 175:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         regular group, function HAL_ADC_Stop must be used to stop both
 176:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         injected and regular groups, and disable the ADC.
 177:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   If injected group mode auto-injection is enabled,
 178:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         function HAL_ADC_Stop must be used.
 179:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
 180:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 181:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval None
 182:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 183:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
 184:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
 111              		.loc 1 184 0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 0
 114              		@ frame_needed = 0, uses_anonymous_args = 0
 115              	.LVL5:
 185:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 186:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 187:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 188:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 189:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 190:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process locked */
 191:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_LOCK(hadc);
 116              		.loc 1 191 0
 117 0000 90F84830 		ldrb	r3, [r0, #72]	@ zero_extendqisi2
 118 0004 012B     		cmp	r3, #1
 119 0006 25D0     		beq	.L14
 184:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 120              		.loc 1 184 0 discriminator 2
 121 0008 10B5     		push	{r4, lr}
 122              	.LCFI1:
 123              		.cfi_def_cfa_offset 8
 124              		.cfi_offset 4, -8
 125              		.cfi_offset 14, -4
 126 000a 0446     		mov	r4, r0
 127              		.loc 1 191 0 discriminator 2
 128 000c 0123     		movs	r3, #1
 129 000e 80F84830 		strb	r3, [r0, #72]
 192:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 193:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Stop potential conversion and disable ADC peripheral                     */
 194:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Conditioned to:                                                          */
 195:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* - No conversion on the other group (regular group) is intended to        */
 196:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   continue (injected and regular groups stop conversion and ADC disable  */
 197:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   are common)                                                            */
 198:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
 199:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
 130              		.loc 1 199 0 discriminator 2
 131 0012 C36C     		ldr	r3, [r0, #76]
 132 0014 13F4807F 		tst	r3, #256
ARM GAS  /tmp/ccZBs9AV.s 			page 7


 133 0018 04D1     		bne	.L12
 200:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
 134              		.loc 1 200 0 discriminator 1
 135 001a 0368     		ldr	r3, [r0]
 136 001c 5B68     		ldr	r3, [r3, #4]
 199:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
 137              		.loc 1 199 0 discriminator 1
 138 001e 13F4806F 		tst	r3, #1024
 139 0022 09D0     		beq	.L19
 140              	.L12:
 201:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 202:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Stop potential conversion on going, on regular and injected groups */
 203:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Disable ADC peripheral */
 204:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 205:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 206:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Check if ADC is effectively disabled */
 207:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (tmp_hal_status == HAL_OK)
 208:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 209:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Set ADC state */
 210:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       ADC_STATE_CLR_SET(hadc->State,
 211:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
 212:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                         HAL_ADC_STATE_READY);
 213:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 214:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 215:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else
 216:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 217:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Update ADC state machine to error */
 218:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 141              		.loc 1 218 0
 142 0024 E36C     		ldr	r3, [r4, #76]
 143 0026 43F02003 		orr	r3, r3, #32
 144 002a E364     		str	r3, [r4, #76]
 145              	.LVL6:
 219:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       
 220:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     tmp_hal_status = HAL_ERROR;
 146              		.loc 1 220 0
 147 002c 0123     		movs	r3, #1
 148              	.LVL7:
 149              	.L13:
 221:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 222:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 223:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process unlocked */
 224:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_UNLOCK(hadc);
 150              		.loc 1 224 0
 151 002e 0022     		movs	r2, #0
 152 0030 84F84820 		strb	r2, [r4, #72]
 225:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 226:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return function status */
 227:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return tmp_hal_status;
 228:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 153              		.loc 1 228 0
 154 0034 1846     		mov	r0, r3
 155 0036 10BD     		pop	{r4, pc}
 156              	.LVL8:
 157              	.L19:
 204:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 158              		.loc 1 204 0
ARM GAS  /tmp/ccZBs9AV.s 			page 8


 159 0038 FFF7FEFF 		bl	ADC_ConversionStop_Disable
 160              	.LVL9:
 207:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 161              		.loc 1 207 0
 162 003c 0346     		mov	r3, r0
 163 003e 0028     		cmp	r0, #0
 164 0040 F5D1     		bne	.L13
 210:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
 165              		.loc 1 210 0
 166 0042 E26C     		ldr	r2, [r4, #76]
 167 0044 22F48852 		bic	r2, r2, #4352
 168 0048 22F00102 		bic	r2, r2, #1
 169 004c 42F00102 		orr	r2, r2, #1
 170 0050 E264     		str	r2, [r4, #76]
 171 0052 ECE7     		b	.L13
 172              	.LVL10:
 173              	.L14:
 174              	.LCFI2:
 175              		.cfi_def_cfa_offset 0
 176              		.cfi_restore 4
 177              		.cfi_restore 14
 191:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 178              		.loc 1 191 0
 179 0054 0223     		movs	r3, #2
 180              		.loc 1 228 0
 181 0056 1846     		mov	r0, r3
 182              	.LVL11:
 183 0058 7047     		bx	lr
 184              		.cfi_endproc
 185              	.LFE73:
 187              		.section	.text.HAL_ADCEx_InjectedPollForConversion,"ax",%progbits
 188              		.align	1
 189              		.global	HAL_ADCEx_InjectedPollForConversion
 190              		.syntax unified
 191              		.thumb
 192              		.thumb_func
 193              		.fpu softvfp
 195              	HAL_ADCEx_InjectedPollForConversion:
 196              	.LFB74:
 229:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 230:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 231:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Wait for injected group conversion to be completed.
 232:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 233:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  Timeout Timeout value in millisecond.
 234:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval HAL status
 235:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 236:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
 237:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
 197              		.loc 1 237 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              	.LVL12:
 202 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 203              	.LCFI3:
 204              		.cfi_def_cfa_offset 24
 205              		.cfi_offset 4, -24
ARM GAS  /tmp/ccZBs9AV.s 			page 9


 206              		.cfi_offset 5, -20
 207              		.cfi_offset 6, -16
 208              		.cfi_offset 7, -12
 209              		.cfi_offset 8, -8
 210              		.cfi_offset 14, -4
 211 0004 0446     		mov	r4, r0
 212 0006 0D46     		mov	r5, r1
 213              	.LVL13:
 238:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   uint32_t tickstart;
 239:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 240:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Variables for polling in case of scan mode enabled and polling for each  */
 241:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* conversion.                                                              */
 242:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Note: Variable "conversion_timeout_cpu_cycles" set to offset 28 CPU      */
 243:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* cycles to compensate number of CPU cycles for processing of variable     */
 244:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* "conversion_timeout_cpu_cycles_max"                                      */
 245:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   uint32_t conversion_timeout_cpu_cycles = 28;
 246:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   uint32_t conversion_timeout_cpu_cycles_max = 0;
 247:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 248:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 249:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 250:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 251:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Get timeout */
 252:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   tickstart = HAL_GetTick();  
 214              		.loc 1 252 0
 215 0008 FFF7FEFF 		bl	HAL_GetTick
 216              	.LVL14:
 217 000c 0746     		mov	r7, r0
 218              	.LVL15:
 253:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      
 254:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Polling for end of conversion: differentiation if single/sequence        */
 255:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* conversion.                                                              */
 256:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* For injected group, flag JEOC is set only at the end of the sequence,    */
 257:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* not for each conversion within the sequence.                             */
 258:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* If setting "EOCSelection" is set to poll for each single conversion,     */
 259:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* management of polling depends on setting of injected group sequencer:    */ 
 260:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*  - If single conversion for injected group (scan mode disabled or        */
 261:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    InjectedNbrOfConversion ==1), flag JEOC is used to determine the      */
 262:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    conversion completion.                                                */
 263:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*  - If sequence conversion for injected group (scan mode enabled and      */
 264:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    InjectedNbrOfConversion >=2), flag JEOC is set only at the end of the */
 265:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    sequence.                                                             */
 266:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    To poll for each conversion, the maximum conversion time is computed  */
 267:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    from ADC conversion time (selected sampling time + conversion time of */
 268:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    12 ADC clock cycles) and APB2/ADC clock prescalers (depending on      */
 269:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    settings, conversion time range can vary from 8 to several thousands  */
 270:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*    of CPU cycles).                                                       */
 271:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 272:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Note: On STM32L1, setting "EOCSelection" is related to regular group     */
 273:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       only, by hardware. For compatibility with other STM32 devices,     */
 274:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       this setting is related also to injected group by software.        */
 275:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (((hadc->Instance->JSQR & ADC_JSQR_JL) == RESET)  ||
 219              		.loc 1 275 0
 220 000e 2368     		ldr	r3, [r4]
 221 0010 5A6C     		ldr	r2, [r3, #68]
 222 0012 12F4401F 		tst	r2, #3145728
 223 0016 03D0     		beq	.L23
 276:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (hadc->Init.EOCSelection != ADC_EOC_SINGLE_CONV)   )
ARM GAS  /tmp/ccZBs9AV.s 			page 10


 224              		.loc 1 276 0 discriminator 1
 225 0018 6269     		ldr	r2, [r4, #20]
 275:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (hadc->Init.EOCSelection != ADC_EOC_SINGLE_CONV)   )
 226              		.loc 1 275 0 discriminator 1
 227 001a B2F5806F 		cmp	r2, #1024
 228 001e 17D0     		beq	.L46
 229              	.LVL16:
 230              	.L23:
 277:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 278:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Wait until End of Conversion flag is raised */
 279:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
 231              		.loc 1 279 0
 232 0020 2368     		ldr	r3, [r4]
 233 0022 1B68     		ldr	r3, [r3]
 234 0024 13F0040F 		tst	r3, #4
 235 0028 4ED1     		bne	.L27
 280:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 281:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Check if timeout is disabled (set to infinite wait) */
 282:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       if(Timeout != HAL_MAX_DELAY)
 236              		.loc 1 282 0
 237 002a B5F1FF3F 		cmp	r5, #-1
 238 002e F7D0     		beq	.L23
 283:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 284:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 239              		.loc 1 284 0
 240 0030 25B1     		cbz	r5, .L24
 241              		.loc 1 284 0 is_stmt 0 discriminator 1
 242 0032 FFF7FEFF 		bl	HAL_GetTick
 243              	.LVL17:
 244 0036 C01B     		subs	r0, r0, r7
 245 0038 8542     		cmp	r5, r0
 246 003a F1D2     		bcs	.L23
 247              	.L24:
 285:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         {
 286:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           /* Update ADC state machine to timeout */
 287:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 248              		.loc 1 287 0 is_stmt 1
 249 003c E36C     		ldr	r3, [r4, #76]
 250 003e 43F00403 		orr	r3, r3, #4
 251 0042 E364     		str	r3, [r4, #76]
 288:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           
 289:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           /* Process unlocked */
 290:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           __HAL_UNLOCK(hadc);
 252              		.loc 1 290 0
 253 0044 0023     		movs	r3, #0
 254 0046 84F84830 		strb	r3, [r4, #72]
 291:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           
 292:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           return HAL_TIMEOUT;
 255              		.loc 1 292 0
 256 004a 0320     		movs	r0, #3
 257 004c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 258              	.LVL18:
 259              	.L46:
 293:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         }
 294:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 295:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 296:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
ARM GAS  /tmp/ccZBs9AV.s 			page 11


 297:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else
 298:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 299:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Computation of CPU cycles corresponding to ADC conversion cycles.      */
 300:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Retrieve ADC clock prescaler and ADC maximum conversion cycles on all  */
 301:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* channels.                                                              */
 302:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     conversion_timeout_cpu_cycles_max = ADC_GET_CLOCK_PRESCALER_DECIMAL(hadc);
 260              		.loc 1 302 0
 261 0050 3F4A     		ldr	r2, .L47
 262 0052 5268     		ldr	r2, [r2, #4]
 263 0054 02F44032 		and	r2, r2, #196608
 264              	.LVL19:
 265              	.LBB4:
 266              	.LBB5:
 267              		.file 2 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h"
   1:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /*
   8:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  10:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  12:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  16:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  *
  18:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
  24:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  25:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  28:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  34:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  38:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
  39:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  43:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
ARM GAS  /tmp/ccZBs9AV.s 			page 12


  44:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  46:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  49:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  55:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  58:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  61:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  64:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  67:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  70:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  78:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  86:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
  94:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
ARM GAS  /tmp/ccZBs9AV.s 			page 13


 101:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 102:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 110:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 113:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 116:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 117:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 118:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   @{
 122:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 123:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 124:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 125:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 129:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 131:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 133:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 134:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 135:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 136:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 140:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 142:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 144:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 145:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 146:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 147:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 151:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 153:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 155:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccZBs9AV.s 			page 14


 158:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 159:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 160:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 162:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 166:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 168:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 170:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 173:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 174:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 175:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 176:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 177:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 181:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 183:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 185:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 186:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 187:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 189:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 193:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 195:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 197:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 198:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 199:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 200:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 201:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 205:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 207:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 209:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 212:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 213:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 214:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccZBs9AV.s 			page 15


 215:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 219:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 221:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 223:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 226:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 227:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 228:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 229:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 233:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 235:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 237:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 240:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 241:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 242:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 243:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 247:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 249:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 251:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 254:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 255:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 256:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 258:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 262:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 264:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 266:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 269:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 270:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 271:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccZBs9AV.s 			page 16


 272:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 273:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 277:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 279:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 281:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 282:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 283:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 285:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 289:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 291:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 293:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 294:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 295:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 296:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 297:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 301:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 303:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 305:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 308:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 309:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 310:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 312:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 316:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 318:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 320:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 323:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 324:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 325:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 326:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 327:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
ARM GAS  /tmp/ccZBs9AV.s 			page 17


 329:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 331:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 333:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 335:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 336:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 337:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 339:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 343:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 345:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 347:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 348:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 349:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 350:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 352:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 356:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 358:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 360:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 363:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 364:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 365:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 366:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 370:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 372:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 374:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 375:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 376:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 377:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 378:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 382:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 384:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccZBs9AV.s 			page 18


 386:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 389:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 390:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 391:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 393:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 397:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 399:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 401:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 404:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 405:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 406:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 407:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 408:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 412:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 414:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 416:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 417:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 418:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 420:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 424:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 426:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 428:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 429:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 430:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 431:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 435:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 439:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 441:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccZBs9AV.s 			page 19


 443:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 444:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 445:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 446:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 450:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 452:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 454:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 455:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 456:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 457:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 461:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 463:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 465:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 468:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 469:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 470:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 472:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 476:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 478:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 480:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 483:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 484:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 485:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 486:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 487:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 491:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 493:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 495:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 496:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 497:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 499:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
ARM GAS  /tmp/ccZBs9AV.s 			page 20


 500:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 503:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 505:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 507:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 508:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 509:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 510:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 511:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 516:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 518:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 520:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 521:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 522:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 523:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 527:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 529:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 531:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 534:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 535:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 536:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 538:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 542:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 544:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 546:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 549:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 550:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 551:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 552:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 553:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccZBs9AV.s 			page 21


 557:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 559:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 561:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 562:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 563:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 565:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 569:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 571:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 573:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 574:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 575:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 579:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 580:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 583:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 584:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   
 589:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 592:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 594:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 599:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 603:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 604:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 605:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 607:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 611:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccZBs9AV.s 			page 22


 614:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 616:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 620:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 624:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 625:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 626:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 627:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 628:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 629:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   
 634:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 637:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 639:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 644:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 646:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 647:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 648:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 649:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 651:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 655:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 658:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 660:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 664:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 666:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 667:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 668:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 669:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 670:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccZBs9AV.s 			page 23


 671:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 676:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 679:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 681:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 686:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 690:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 691:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 692:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 693:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 695:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 699:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 702:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 704:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 708:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 712:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 713:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 714:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 715:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 716:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 717:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 722:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 725:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 727:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
ARM GAS  /tmp/ccZBs9AV.s 			page 24


 728:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 732:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 734:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 735:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 736:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 737:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 739:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 743:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 746:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 748:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 752:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 754:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 755:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 756:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 757:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 760:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 761:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 762:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 766:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 768:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 776:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 778:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 781:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 782:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 784:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccZBs9AV.s 			page 25


 785:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 786:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 787:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 788:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 792:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 794:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 802:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 804:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 805:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 807:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 808:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 809:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 810:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 812:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 813:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   @{
 817:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** */
 818:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 819:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 827:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 831:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 832:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 833:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 836:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 838:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 839:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccZBs9AV.s 			page 26


 842:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 844:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 845:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 846:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 850:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 852:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 853:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 854:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 857:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 859:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 860:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 861:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 866:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 868:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 870:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 871:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 872:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 873:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 877:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 879:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 881:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 882:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 883:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 884:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 888:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 890:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 892:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 893:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 894:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 895:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
ARM GAS  /tmp/ccZBs9AV.s 			page 27


 899:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 900:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 902:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 905:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 907:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 910:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 911:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 912:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 913:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 914:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 919:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 921:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 923:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 926:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 927:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 928:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 929:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 934:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 936:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #else
 939:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 941:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #endif
 944:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 945:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 946:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 947:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 948:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 954:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccZBs9AV.s 			page 28


 956:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   {
 959:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****     return op1;
 960:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   }
 961:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** }
 963:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 964:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 965:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 966:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 972:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 974:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 975:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** /**
 976:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****  */
 981:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** {
 983:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** 
 985:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 268              		.loc 2 988 0
 269 0058 4FF44038 		mov	r8, #196608
 270              		.syntax unified
 271              	@ 988 "..//Source/stm/lib/CMSIS/Include/cmsis_gcc.h" 1
 272 005c 98FAA8F8 		rbit r8, r8
 273              	@ 0 "" 2
 274              	.LVL20:
 275              		.thumb
 276              		.syntax unified
 277              	.LBE5:
 278              	.LBE4:
 279              		.loc 1 302 0
 280 0060 B8FA88F8 		clz	r8, r8
 281 0064 22FA08F2 		lsr	r2, r2, r8
 282              	.LVL21:
 303:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     conversion_timeout_cpu_cycles_max *= ADC_CONVCYCLES_MAX_RANGE(hadc);
 283              		.loc 1 303 0
 284 0068 5869     		ldr	r0, [r3, #20]
 285              	.LVL22:
 286 006a 3A49     		ldr	r1, .L47+4
 287 006c 0842     		tst	r0, r1
 288 006e 09D1     		bne	.L35
 289              		.loc 1 303 0 is_stmt 0 discriminator 1
 290 0070 1869     		ldr	r0, [r3, #16]
ARM GAS  /tmp/ccZBs9AV.s 			page 29


 291 0072 0842     		tst	r0, r1
 292 0074 0CD1     		bne	.L36
 293              		.loc 1 303 0 discriminator 3
 294 0076 D968     		ldr	r1, [r3, #12]
 295 0078 374B     		ldr	r3, .L47+8
 296 007a 1942     		tst	r1, r3
 297 007c 0BD0     		beq	.L37
 298              		.loc 1 303 0
 299 007e 4FF4C678 		mov	r8, #396
 300 0082 01E0     		b	.L28
 301              	.L35:
 302 0084 4FF4C678 		mov	r8, #396
 303              	.L28:
 304              		.loc 1 303 0 discriminator 8
 305 0088 08FA02F8 		lsl	r8, r8, r2
 306              	.LVL23:
 245:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   uint32_t conversion_timeout_cpu_cycles_max = 0;
 307              		.loc 1 245 0 is_stmt 1 discriminator 8
 308 008c 1C26     		movs	r6, #28
 304:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 305:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Poll with maximum conversion time */
 306:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     while(conversion_timeout_cpu_cycles < conversion_timeout_cpu_cycles_max)
 309              		.loc 1 306 0 discriminator 8
 310 008e 06E0     		b	.L29
 311              	.LVL24:
 312              	.L36:
 303:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 313              		.loc 1 303 0
 314 0090 4FF4C678 		mov	r8, #396
 315 0094 F8E7     		b	.L28
 316              	.L37:
 317 0096 4FF02408 		mov	r8, #36
 318 009a F5E7     		b	.L28
 319              	.LVL25:
 320              	.L30:
 307:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 308:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Check if timeout is disabled (set to infinite wait) */
 309:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       if(Timeout != HAL_MAX_DELAY)
 310:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 311:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 312:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         {
 313:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           /* Update ADC state machine to timeout */
 314:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 315:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 316:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           /* Process unlocked */
 317:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           __HAL_UNLOCK(hadc);
 318:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           
 319:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           return HAL_TIMEOUT;
 320:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         }
 321:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 322:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       conversion_timeout_cpu_cycles ++;
 321              		.loc 1 322 0
 322 009c 0136     		adds	r6, r6, #1
 323              	.LVL26:
 324              	.L29:
 306:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 325              		.loc 1 306 0
ARM GAS  /tmp/ccZBs9AV.s 			page 30


 326 009e 4645     		cmp	r6, r8
 327 00a0 12D2     		bcs	.L27
 309:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 328              		.loc 1 309 0
 329 00a2 B5F1FF3F 		cmp	r5, #-1
 330 00a6 F9D0     		beq	.L30
 311:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         {
 331              		.loc 1 311 0
 332 00a8 25B1     		cbz	r5, .L31
 311:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         {
 333              		.loc 1 311 0 is_stmt 0 discriminator 1
 334 00aa FFF7FEFF 		bl	HAL_GetTick
 335              	.LVL27:
 336 00ae C01B     		subs	r0, r0, r7
 337 00b0 8542     		cmp	r5, r0
 338 00b2 F3D2     		bcs	.L30
 339              	.L31:
 314:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 340              		.loc 1 314 0 is_stmt 1
 341 00b4 E36C     		ldr	r3, [r4, #76]
 342 00b6 43F00403 		orr	r3, r3, #4
 343 00ba E364     		str	r3, [r4, #76]
 317:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****           
 344              		.loc 1 317 0
 345 00bc 0023     		movs	r3, #0
 346 00be 84F84830 		strb	r3, [r4, #72]
 319:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         }
 347              		.loc 1 319 0
 348 00c2 0320     		movs	r0, #3
 349 00c4 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 350              	.LVL28:
 351              	.L27:
 323:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 324:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 325:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 326:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Clear end of conversion flag of injected group if low power feature      */
 327:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* "Auto Wait" is disabled, to not interfere with this feature until data   */
 328:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* register is read using function HAL_ADCEx_InjectedGetValue().            */
 329:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (hadc->Init.LowPowerAutoWait == DISABLE)
 352              		.loc 1 329 0
 353 00c8 A369     		ldr	r3, [r4, #24]
 354 00ca 1BB9     		cbnz	r3, .L33
 330:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 331:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Clear injected group conversion flag */
 332:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC);
 355              		.loc 1 332 0
 356 00cc 2368     		ldr	r3, [r4]
 357 00ce 6FF00C02 		mvn	r2, #12
 358 00d2 1A60     		str	r2, [r3]
 359              	.L33:
 333:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 334:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 335:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Update ADC state machine */
 336:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 360              		.loc 1 336 0
 361 00d4 E36C     		ldr	r3, [r4, #76]
 362 00d6 43F40053 		orr	r3, r3, #8192
ARM GAS  /tmp/ccZBs9AV.s 			page 31


 363 00da E364     		str	r3, [r4, #76]
 337:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 338:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Determine whether any further conversion upcoming on group injected      */
 339:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* by external trigger, continuous mode or scan sequence on going.          */
 340:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Note: On STM32L1, there is no independent flag of end of sequence.       */
 341:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       The test of scan sequence on going is done either with scan        */
 342:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       sequence disabled or with end of conversion flag set to            */
 343:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       of end of sequence.                                                */
 344:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 364              		.loc 1 344 0
 365 00dc 2368     		ldr	r3, [r4]
 366 00de 9A68     		ldr	r2, [r3, #8]
 367 00e0 12F4401F 		tst	r2, #3145728
 368 00e4 21D1     		bne	.L38
 345:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 369              		.loc 1 345 0 discriminator 1
 370 00e6 5A6C     		ldr	r2, [r3, #68]
 344:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 371              		.loc 1 344 0 discriminator 1
 372 00e8 12F4401F 		tst	r2, #3145728
 373 00ec 03D0     		beq	.L34
 346:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 374              		.loc 1 346 0
 375 00ee 9A68     		ldr	r2, [r3, #8]
 345:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 376              		.loc 1 345 0
 377 00f0 12F4806F 		tst	r2, #1024
 378 00f4 1CD1     		bne	.L39
 379              	.L34:
 347:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 380              		.loc 1 347 0
 381 00f6 5A68     		ldr	r2, [r3, #4]
 346:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 382              		.loc 1 346 0
 383 00f8 12F4806F 		tst	r2, #1024
 384 00fc 1BD1     		bne	.L40
 348:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 385              		.loc 1 348 0
 386 00fe 9B68     		ldr	r3, [r3, #8]
 347:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 387              		.loc 1 347 0
 388 0100 13F0405F 		tst	r3, #805306368
 389 0104 1AD1     		bne	.L41
 349:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
 390              		.loc 1 349 0
 391 0106 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 348:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 392              		.loc 1 348 0
 393 010a D3B9     		cbnz	r3, .L42
 350:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 351:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Set ADC state */
 352:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 394              		.loc 1 352 0
 395 010c E36C     		ldr	r3, [r4, #76]
 396 010e 23F48053 		bic	r3, r3, #4096
 397 0112 E364     		str	r3, [r4, #76]
 353:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
ARM GAS  /tmp/ccZBs9AV.s 			page 32


 354:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 398              		.loc 1 354 0
 399 0114 E36C     		ldr	r3, [r4, #76]
 400 0116 13F4807F 		tst	r3, #256
 401 011a 15D1     		bne	.L43
 355:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     { 
 356:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 402              		.loc 1 356 0
 403 011c E36C     		ldr	r3, [r4, #76]
 404 011e 43F00103 		orr	r3, r3, #1
 405 0122 E364     		str	r3, [r4, #76]
 357:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 358:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 359:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 360:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return ADC state */
 361:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return HAL_OK;
 406              		.loc 1 361 0
 407 0124 0020     		movs	r0, #0
 408 0126 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 409              	.LVL29:
 410              	.L38:
 411 012a 0020     		movs	r0, #0
 412 012c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 413              	.LVL30:
 414              	.L39:
 415 0130 0020     		movs	r0, #0
 416 0132 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 417              	.LVL31:
 418              	.L40:
 419 0136 0020     		movs	r0, #0
 420 0138 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 421              	.LVL32:
 422              	.L41:
 423 013c 0020     		movs	r0, #0
 424 013e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 425              	.LVL33:
 426              	.L42:
 427 0142 0020     		movs	r0, #0
 428 0144 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 429              	.LVL34:
 430              	.L43:
 431 0148 0020     		movs	r0, #0
 362:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 432              		.loc 1 362 0
 433 014a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 434              	.LVL35:
 435              	.L48:
 436 014e 00BF     		.align	2
 437              	.L47:
 438 0150 00270140 		.word	1073817344
 439 0154 24499224 		.word	613566756
 440 0158 24491200 		.word	1198372
 441              		.cfi_endproc
 442              	.LFE74:
 444              		.section	.text.HAL_ADCEx_InjectedStart_IT,"ax",%progbits
 445              		.align	1
 446              		.global	HAL_ADCEx_InjectedStart_IT
ARM GAS  /tmp/ccZBs9AV.s 			page 33


 447              		.syntax unified
 448              		.thumb
 449              		.thumb_func
 450              		.fpu softvfp
 452              	HAL_ADCEx_InjectedStart_IT:
 453              	.LFB75:
 363:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 364:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 365:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Enables ADC, starts conversion of injected group with interruption.
 366:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          - JEOC (end of conversion of injected group)
 367:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         Each of these interruptions has its dedicated callback function.
 368:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 369:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval HAL status.
 370:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 371:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
 372:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
 454              		.loc 1 372 0
 455              		.cfi_startproc
 456              		@ args = 0, pretend = 0, frame = 0
 457              		@ frame_needed = 0, uses_anonymous_args = 0
 458              	.LVL36:
 373:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 374:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 375:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 376:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 377:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 378:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process locked */
 379:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_LOCK(hadc);
 459              		.loc 1 379 0
 460 0000 90F84830 		ldrb	r3, [r0, #72]	@ zero_extendqisi2
 461 0004 012B     		cmp	r3, #1
 462 0006 02D1     		bne	.L57
 463 0008 0223     		movs	r3, #2
 380:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 381:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Enable the ADC peripheral */
 382:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   tmp_hal_status = ADC_Enable(hadc);
 383:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 384:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Start conversion if ADC is effectively enabled */
 385:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (tmp_hal_status == HAL_OK)
 386:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 387:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Set ADC state                                                          */
 388:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* - Clear state bitfield related to injected group conversion results    */
 389:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* - Set state bitfield related to injected operation                     */
 390:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     ADC_STATE_CLR_SET(hadc->State,
 391:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
 392:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       HAL_ADC_STATE_INJ_BUSY);
 393:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 394:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Check if a regular conversion is ongoing */
 395:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Note: On this device, there is no ADC error code fields related to     */
 396:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /*       conversions on group injected only. In case of conversion on     */
 397:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /*       going on group regular, no error code is reset.                  */
 398:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 399:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 400:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Reset ADC all error code fields */
 401:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       ADC_CLEAR_ERRORCODE(hadc);
 402:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 403:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
ARM GAS  /tmp/ccZBs9AV.s 			page 34


 404:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Process unlocked */
 405:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Unlock before starting ADC conversions: in case of potential           */
 406:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* interruption, to let the process to ADC IRQ Handler.                   */
 407:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     __HAL_UNLOCK(hadc);
 408:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 409:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Clear injected group conversion flag */
 410:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* (To ensure of no unknown state from potential previous ADC operations) */
 411:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
 412:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 413:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Enable end of conversion interrupt for injected channels */
 414:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
 415:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 416:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Enable conversion of injected group.                                   */
 417:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If software start has been selected, conversion starts immediately.    */
 418:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If external trigger has been selected, conversion will start at next   */
 419:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* trigger event.                                                         */
 420:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If automatic injected conversion is enabled, conversion will start     */
 421:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* after next regular group conversion.                                   */
 422:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (ADC_IS_SOFTWARE_START_INJECTED(hadc)              && 
 423:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
 424:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 425:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Enable ADC software conversion for injected channels */
 426:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       SET_BIT(hadc->Instance->CR2, ADC_CR2_JSWSTART);
 427:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 428:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 429:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 430:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return function status */
 431:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return tmp_hal_status;
 432:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 464              		.loc 1 432 0
 465 000a 1846     		mov	r0, r3
 466              	.LVL37:
 467 000c 7047     		bx	lr
 468              	.LVL38:
 469              	.L57:
 372:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 470              		.loc 1 372 0 discriminator 2
 471 000e 10B5     		push	{r4, lr}
 472              	.LCFI4:
 473              		.cfi_def_cfa_offset 8
 474              		.cfi_offset 4, -8
 475              		.cfi_offset 14, -4
 476 0010 0446     		mov	r4, r0
 379:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 477              		.loc 1 379 0 discriminator 2
 478 0012 0123     		movs	r3, #1
 479 0014 80F84830 		strb	r3, [r0, #72]
 382:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 480              		.loc 1 382 0 discriminator 2
 481 0018 FFF7FEFF 		bl	ADC_Enable
 482              	.LVL39:
 385:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 483              		.loc 1 385 0 discriminator 2
 484 001c 0346     		mov	r3, r0
 485 001e 30BB     		cbnz	r0, .L50
 390:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                       HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
 486              		.loc 1 390 0
ARM GAS  /tmp/ccZBs9AV.s 			page 35


 487 0020 E26C     		ldr	r2, [r4, #76]
 488 0022 22F44052 		bic	r2, r2, #12288
 489 0026 22F00102 		bic	r2, r2, #1
 490 002a 42F48052 		orr	r2, r2, #4096
 491 002e E264     		str	r2, [r4, #76]
 398:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 492              		.loc 1 398 0
 493 0030 E26C     		ldr	r2, [r4, #76]
 494 0032 12F4807F 		tst	r2, #256
 495 0036 01D1     		bne	.L51
 401:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 496              		.loc 1 401 0
 497 0038 0022     		movs	r2, #0
 498 003a 2265     		str	r2, [r4, #80]
 499              	.L51:
 407:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 500              		.loc 1 407 0
 501 003c 0022     		movs	r2, #0
 502 003e 84F84820 		strb	r2, [r4, #72]
 411:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 503              		.loc 1 411 0
 504 0042 2268     		ldr	r2, [r4]
 505 0044 6FF00401 		mvn	r1, #4
 506 0048 1160     		str	r1, [r2]
 414:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 507              		.loc 1 414 0
 508 004a 2168     		ldr	r1, [r4]
 509 004c 4A68     		ldr	r2, [r1, #4]
 510 004e 42F08002 		orr	r2, r2, #128
 511 0052 4A60     		str	r2, [r1, #4]
 422:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
 512              		.loc 1 422 0
 513 0054 2268     		ldr	r2, [r4]
 514 0056 9168     		ldr	r1, [r2, #8]
 515 0058 11F4401F 		tst	r1, #3145728
 516 005c 07D1     		bne	.L50
 423:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 517              		.loc 1 423 0 discriminator 1
 518 005e 5168     		ldr	r1, [r2, #4]
 422:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)  )
 519              		.loc 1 422 0 discriminator 1
 520 0060 11F4806F 		tst	r1, #1024
 521 0064 03D1     		bne	.L50
 426:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 522              		.loc 1 426 0
 523 0066 9168     		ldr	r1, [r2, #8]
 524 0068 41F48001 		orr	r1, r1, #4194304
 525 006c 9160     		str	r1, [r2, #8]
 526              	.L50:
 527              		.loc 1 432 0
 528 006e 1846     		mov	r0, r3
 529              	.LVL40:
 530 0070 10BD     		pop	{r4, pc}
 531              		.cfi_endproc
 532              	.LFE75:
 534              		.section	.text.HAL_ADCEx_InjectedStop_IT,"ax",%progbits
 535              		.align	1
ARM GAS  /tmp/ccZBs9AV.s 			page 36


 536              		.global	HAL_ADCEx_InjectedStop_IT
 537              		.syntax unified
 538              		.thumb
 539              		.thumb_func
 540              		.fpu softvfp
 542              	HAL_ADCEx_InjectedStop_IT:
 543              	.LFB76:
 433:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 434:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 435:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Stop conversion of injected channels, disable interruption of 
 436:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         end-of-conversion. Disable ADC peripheral if no regular conversion
 437:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         is on going.
 438:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   If ADC must be disabled and if conversion is on going on 
 439:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         regular group, function HAL_ADC_Stop must be used to stop both
 440:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         injected and regular groups, and disable the ADC.
 441:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   If injected group mode auto-injection is enabled,
 442:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         function HAL_ADC_Stop must be used.
 443:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 444:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval None
 445:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 446:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
 447:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
 544              		.loc 1 447 0
 545              		.cfi_startproc
 546              		@ args = 0, pretend = 0, frame = 0
 547              		@ frame_needed = 0, uses_anonymous_args = 0
 548              	.LVL41:
 448:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 449:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 450:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 451:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 452:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 453:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process locked */
 454:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_LOCK(hadc);
 549              		.loc 1 454 0
 550 0000 90F84830 		ldrb	r3, [r0, #72]	@ zero_extendqisi2
 551 0004 012B     		cmp	r3, #1
 552 0006 2AD0     		beq	.L62
 447:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 553              		.loc 1 447 0 discriminator 2
 554 0008 10B5     		push	{r4, lr}
 555              	.LCFI5:
 556              		.cfi_def_cfa_offset 8
 557              		.cfi_offset 4, -8
 558              		.cfi_offset 14, -4
 559 000a 0446     		mov	r4, r0
 560              		.loc 1 454 0 discriminator 2
 561 000c 0123     		movs	r3, #1
 562 000e 80F84830 		strb	r3, [r0, #72]
 455:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 456:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Stop potential conversion and disable ADC peripheral                     */
 457:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Conditioned to:                                                          */
 458:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* - No conversion on the other group (regular group) is intended to        */
 459:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   continue (injected and regular groups stop conversion and ADC disable  */
 460:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   are common)                                                            */
 461:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
 462:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
ARM GAS  /tmp/ccZBs9AV.s 			page 37


 563              		.loc 1 462 0 discriminator 2
 564 0012 C36C     		ldr	r3, [r0, #76]
 565 0014 13F4807F 		tst	r3, #256
 566 0018 04D1     		bne	.L60
 463:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
 567              		.loc 1 463 0 discriminator 1
 568 001a 0368     		ldr	r3, [r0]
 569 001c 5B68     		ldr	r3, [r3, #4]
 462:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****      HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
 570              		.loc 1 462 0 discriminator 1
 571 001e 13F4806F 		tst	r3, #1024
 572 0022 09D0     		beq	.L67
 573              	.L60:
 464:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 465:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Stop potential conversion on going, on regular and injected groups */
 466:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Disable ADC peripheral */
 467:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 468:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 469:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Check if ADC is effectively disabled */
 470:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (tmp_hal_status == HAL_OK)
 471:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 472:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Disable ADC end of conversion interrupt for injected channels */
 473:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 474:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       
 475:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Set ADC state */
 476:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       ADC_STATE_CLR_SET(hadc->State,
 477:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
 478:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                         HAL_ADC_STATE_READY);
 479:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 480:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 481:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else
 482:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 483:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Update ADC state machine to error */
 484:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 574              		.loc 1 484 0
 575 0024 E36C     		ldr	r3, [r4, #76]
 576 0026 43F02003 		orr	r3, r3, #32
 577 002a E364     		str	r3, [r4, #76]
 578              	.LVL42:
 485:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       
 486:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     tmp_hal_status = HAL_ERROR;
 579              		.loc 1 486 0
 580 002c 0123     		movs	r3, #1
 581              	.LVL43:
 582              	.L61:
 487:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 488:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 489:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process unlocked */
 490:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_UNLOCK(hadc);
 583              		.loc 1 490 0
 584 002e 0022     		movs	r2, #0
 585 0030 84F84820 		strb	r2, [r4, #72]
 491:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 492:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return function status */
 493:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return tmp_hal_status;
 494:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 586              		.loc 1 494 0
ARM GAS  /tmp/ccZBs9AV.s 			page 38


 587 0034 1846     		mov	r0, r3
 588 0036 10BD     		pop	{r4, pc}
 589              	.LVL44:
 590              	.L67:
 467:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 591              		.loc 1 467 0
 592 0038 FFF7FEFF 		bl	ADC_ConversionStop_Disable
 593              	.LVL45:
 470:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 594              		.loc 1 470 0
 595 003c 0346     		mov	r3, r0
 596 003e 0028     		cmp	r0, #0
 597 0040 F5D1     		bne	.L61
 473:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       
 598              		.loc 1 473 0
 599 0042 2168     		ldr	r1, [r4]
 600 0044 4A68     		ldr	r2, [r1, #4]
 601 0046 22F08002 		bic	r2, r2, #128
 602 004a 4A60     		str	r2, [r1, #4]
 476:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
 603              		.loc 1 476 0
 604 004c E26C     		ldr	r2, [r4, #76]
 605 004e 22F48852 		bic	r2, r2, #4352
 606 0052 22F00102 		bic	r2, r2, #1
 607 0056 42F00102 		orr	r2, r2, #1
 608 005a E264     		str	r2, [r4, #76]
 609 005c E7E7     		b	.L61
 610              	.LVL46:
 611              	.L62:
 612              	.LCFI6:
 613              		.cfi_def_cfa_offset 0
 614              		.cfi_restore 4
 615              		.cfi_restore 14
 454:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 616              		.loc 1 454 0
 617 005e 0223     		movs	r3, #2
 618              		.loc 1 494 0
 619 0060 1846     		mov	r0, r3
 620              	.LVL47:
 621 0062 7047     		bx	lr
 622              		.cfi_endproc
 623              	.LFE76:
 625              		.section	.text.HAL_ADCEx_InjectedGetValue,"ax",%progbits
 626              		.align	1
 627              		.global	HAL_ADCEx_InjectedGetValue
 628              		.syntax unified
 629              		.thumb
 630              		.thumb_func
 631              		.fpu softvfp
 633              	HAL_ADCEx_InjectedGetValue:
 634              	.LFB77:
 495:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 496:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 497:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Get ADC injected group conversion result.
 498:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   Reading register JDRx automatically clears ADC flag JEOC
 499:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         (ADC group injected end of unitary conversion).
 500:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   This function does not clear ADC flag JEOS 
ARM GAS  /tmp/ccZBs9AV.s 			page 39


 501:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         (ADC group injected end of sequence conversion)
 502:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         Occurrence of flag JEOS rising:
 503:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          - If sequencer is composed of 1 rank, flag JEOS is equivalent
 504:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            to flag JEOC.
 505:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          - If sequencer is composed of several ranks, during the scan
 506:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            sequence flag JEOC only is raised, at the end of the scan sequence
 507:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            both flags JEOC and EOS are raised.
 508:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         Flag JEOS must not be cleared by this function because
 509:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         it would not be compliant with low power features
 510:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         (feature low power auto-wait, not available on all STM32 families).
 511:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         To clear this flag, either use function: 
 512:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
 513:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         model polling: @ref HAL_ADCEx_InjectedPollForConversion() 
 514:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_JEOS).
 515:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 516:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  InjectedRank the converted ADC injected rank.
 517:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *          This parameter can be one of the following values:
 518:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
 519:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
 520:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
 521:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
 522:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval ADC group injected conversion data
 523:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 524:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
 525:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
 635              		.loc 1 525 0
 636              		.cfi_startproc
 637              		@ args = 0, pretend = 0, frame = 0
 638              		@ frame_needed = 0, uses_anonymous_args = 0
 639              		@ link register save eliminated.
 640              	.LVL48:
 526:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   uint32_t tmp_jdr = 0;
 527:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 528:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 529:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 530:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
 531:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 532:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Get ADC converted value */
 533:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   switch(InjectedRank)
 641              		.loc 1 533 0
 642 0000 0329     		cmp	r1, #3
 643 0002 09D0     		beq	.L70
 644 0004 0429     		cmp	r1, #4
 645 0006 04D0     		beq	.L71
 646 0008 0229     		cmp	r1, #2
 647 000a 08D0     		beq	.L75
 534:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {  
 535:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_4:
 536:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       tmp_jdr = hadc->Instance->JDR4;
 537:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 538:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_3: 
 539:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       tmp_jdr = hadc->Instance->JDR3;
 540:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 541:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_2: 
 542:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       tmp_jdr = hadc->Instance->JDR2;
 543:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 544:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_1:
ARM GAS  /tmp/ccZBs9AV.s 			page 40


 545:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     default:
 546:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       tmp_jdr = hadc->Instance->JDR1;
 648              		.loc 1 546 0
 649 000c 0368     		ldr	r3, [r0]
 650 000e 986C     		ldr	r0, [r3, #72]
 651              	.LVL49:
 547:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 548:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 549:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 550:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return ADC converted value */ 
 551:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return tmp_jdr;
 552:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 652              		.loc 1 552 0
 653 0010 7047     		bx	lr
 654              	.LVL50:
 655              	.L71:
 536:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 656              		.loc 1 536 0
 657 0012 0368     		ldr	r3, [r0]
 658 0014 586D     		ldr	r0, [r3, #84]
 659              	.LVL51:
 537:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_3: 
 660              		.loc 1 537 0
 661 0016 7047     		bx	lr
 662              	.LVL52:
 663              	.L70:
 539:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 664              		.loc 1 539 0
 665 0018 0368     		ldr	r3, [r0]
 666 001a 186D     		ldr	r0, [r3, #80]
 667              	.LVL53:
 540:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_2: 
 668              		.loc 1 540 0
 669 001c 7047     		bx	lr
 670              	.LVL54:
 671              	.L75:
 542:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 672              		.loc 1 542 0
 673 001e 0368     		ldr	r3, [r0]
 674 0020 D86C     		ldr	r0, [r3, #76]
 675              	.LVL55:
 543:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case ADC_INJECTED_RANK_1:
 676              		.loc 1 543 0
 677 0022 7047     		bx	lr
 678              		.cfi_endproc
 679              	.LFE77:
 681              		.section	.text.HAL_ADCEx_InjectedConvCpltCallback,"ax",%progbits
 682              		.align	1
 683              		.weak	HAL_ADCEx_InjectedConvCpltCallback
 684              		.syntax unified
 685              		.thumb
 686              		.thumb_func
 687              		.fpu softvfp
 689              	HAL_ADCEx_InjectedConvCpltCallback:
 690              	.LFB78:
 553:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 554:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
ARM GAS  /tmp/ccZBs9AV.s 			page 41


 555:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Injected conversion complete callback in non blocking mode 
 556:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 557:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval None
 558:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 559:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
 560:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {
 691              		.loc 1 560 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 0
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              		@ link register save eliminated.
 696              	.LVL56:
 697 0000 7047     		bx	lr
 698              		.cfi_endproc
 699              	.LFE78:
 701              		.section	.text.HAL_ADCEx_InjectedConfigChannel,"ax",%progbits
 702              		.align	1
 703              		.global	HAL_ADCEx_InjectedConfigChannel
 704              		.syntax unified
 705              		.thumb
 706              		.thumb_func
 707              		.fpu softvfp
 709              	HAL_ADCEx_InjectedConfigChannel:
 710              	.LFB79:
 561:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Prevent unused argument(s) compilation warning */
 562:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   UNUSED(hadc);
 563:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 564:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* NOTE : This function Should not be modified, when the callback is needed,
 565:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****             the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
 566:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 567:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 568:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 569:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 570:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @}
 571:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 572:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 573:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /** @defgroup ADCEx_Exported_Functions_Group2 ADC Extended Peripheral Control functions
 574:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief    ADC Extended Peripheral Control functions
 575:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *
 576:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** @verbatim   
 577:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****  ===============================================================================
 578:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****              ##### Peripheral Control functions #####
 579:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****  ===============================================================================  
 580:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     [..]  This section provides functions allowing to:
 581:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (+) Configure channels on injected group
 582:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       
 583:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** @endverbatim
 584:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @{
 585:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 586:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 587:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** /**
 588:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @brief  Configures the ADC injected group and the selected channel to be
 589:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         linked to the injected group.
 590:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @note   Possibility to update parameters on the fly:
 591:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         This function initializes injected group, following calls to this 
 592:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         function can be used to reconfigure some parameters of structure
 593:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         "ADC_InjectionConfTypeDef" on the fly, without reseting the ADC.
ARM GAS  /tmp/ccZBs9AV.s 			page 42


 594:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         The setting of these parameters is conditioned to ADC state: 
 595:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         this function must be called when ADC is not under conversion.
 596:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  hadc ADC handle
 597:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @param  sConfigInjected Structure of ADC injected group and ADC channel for
 598:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   *         injected group.
 599:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   * @retval None
 600:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   */
 601:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef
 602:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** {   
 711              		.loc 1 602 0
 712              		.cfi_startproc
 713              		@ args = 0, pretend = 0, frame = 8
 714              		@ frame_needed = 0, uses_anonymous_args = 0
 715              		@ link register save eliminated.
 716              	.LVL57:
 717              		.loc 1 602 0
 718 0000 F0B4     		push	{r4, r5, r6, r7}
 719              	.LCFI7:
 720              		.cfi_def_cfa_offset 16
 721              		.cfi_offset 4, -16
 722              		.cfi_offset 5, -12
 723              		.cfi_offset 6, -8
 724              		.cfi_offset 7, -4
 725 0002 82B0     		sub	sp, sp, #8
 726              	.LCFI8:
 727              		.cfi_def_cfa_offset 24
 728 0004 0346     		mov	r3, r0
 729              	.LVL58:
 603:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 604:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __IO uint32_t wait_loop_index = 0;
 730              		.loc 1 604 0
 731 0006 0022     		movs	r2, #0
 732 0008 0192     		str	r2, [sp, #4]
 605:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 606:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Check the parameters */
 607:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 608:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
 609:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
 610:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
 611:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_EXTTRIGINJEC(sConfigInjected->ExternalTrigInjecConv));
 612:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   assert_param(IS_ADC_RANGE(ADC_RESOLUTION_12B, sConfigInjected->InjectedOffset));
 613:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 614:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 733              		.loc 1 614 0
 734 000a 0069     		ldr	r0, [r0, #16]
 735              	.LVL59:
 615:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 616:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
 617:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     assert_param(IS_ADC_INJECTED_NB_CONV(sConfigInjected->InjectedNbrOfConversion));
 618:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
 619:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 620:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 621:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 622:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 623:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     assert_param(IS_ADC_EXTTRIGINJEC_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
 624:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 625:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
ARM GAS  /tmp/ccZBs9AV.s 			page 43


 626:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process locked */
 627:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_LOCK(hadc);
 736              		.loc 1 627 0
 737 000c 93F84820 		ldrb	r2, [r3, #72]	@ zero_extendqisi2
 738 0010 012A     		cmp	r2, #1
 739 0012 00F00681 		beq	.L101
 740              		.loc 1 627 0 is_stmt 0 discriminator 2
 741 0016 0122     		movs	r2, #1
 742 0018 83F84820 		strb	r2, [r3, #72]
 628:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 629:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Configuration of injected group sequencer:                               */
 630:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* - if scan mode is disabled, injected channels sequence length is set to  */
 631:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   0x00: 1 channel converted (channel on regular rank 1)                  */
 632:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   Parameter "InjectedNbrOfConversion" is discarded.                      */
 633:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   Note: Scan mode is present by hardware on this device and, if          */
 634:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   disabled, discards automatically nb of conversions. Anyway, nb of      */
 635:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   conversions is forced to 0x00 for alignment over all STM32 devices.    */
 636:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* - if scan mode is enabled, injected channels sequence length is set to   */
 637:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*   parameter ""InjectedNbrOfConversion".                                  */
 638:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 743              		.loc 1 638 0 is_stmt 1 discriminator 2
 744 001c 0028     		cmp	r0, #0
 745 001e 4FD1     		bne	.L79
 639:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 640:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 746              		.loc 1 640 0
 747 0020 4A68     		ldr	r2, [r1, #4]
 748 0022 012A     		cmp	r2, #1
 749 0024 42D0     		beq	.L104
 641:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 642:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Clear the old SQx bits for all injected ranks */
 643:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         MODIFY_REG(hadc->Instance->JSQR                              ,
 644:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_JL   |
 645:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_JSQ4 |
 646:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_JSQ3 |
 647:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_JSQ2 |
 648:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_JSQ1                                     ,
 649:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,
 650:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                     ADC_INJECTED_RANK_1,
 651:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                     0x01)                             );
 652:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 653:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* If another injected rank than rank1 was intended to be set, and could  */
 654:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* not due to ScanConvMode disabled, error is reported.                   */
 655:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     else
 656:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 657:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Update ADC state machine to error */
 658:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 750              		.loc 1 658 0
 751 0026 DA6C     		ldr	r2, [r3, #76]
 752 0028 42F02002 		orr	r2, r2, #32
 753 002c DA64     		str	r2, [r3, #76]
 754              	.LVL60:
 659:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         
 660:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       tmp_hal_status = HAL_ERROR;
 755              		.loc 1 660 0
 756 002e 0120     		movs	r0, #1
 757              	.LVL61:
ARM GAS  /tmp/ccZBs9AV.s 			page 44


 758              	.L81:
 661:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 662:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 663:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else
 664:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {   
 665:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Since injected channels rank conv. order depends on total number of   */
 666:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* injected conversions, selected rank must be below or equal to total   */
 667:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* number of injected conversions to be updated.                         */
 668:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (sConfigInjected->InjectedRank <= sConfigInjected->InjectedNbrOfConversion)
 669:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 670:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Clear the old SQx bits for the selected rank */
 671:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Set the SQx bits for the selected rank */
 672:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       MODIFY_REG(hadc->Instance->JSQR                                                     ,
 673:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  
 674:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JSQR_JL                                               |
 675:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
 676:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                   sConfigInjected->InjectedRank,         
 677:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                   sConfigInjected->InjectedNbrOfConversion)               ,
 678:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  
 679:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JSQR_JL_SHIFT(sConfigInjected->InjectedNbrOfConversion)             |
 680:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,      
 681:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                                 sConfigInjected->InjectedRank,         
 682:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                                 sConfigInjected->InjectedNbrOfConversion)  );
 683:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 684:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     else
 685:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 686:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Clear the old SQx bits for the selected rank */
 687:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       MODIFY_REG(hadc->Instance->JSQR                                       ,
 688:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  
 689:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JSQR_JL                                               |
 690:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
 691:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                   sConfigInjected->InjectedRank,         
 692:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                                   sConfigInjected->InjectedNbrOfConversion) ,
 693:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  
 694:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  0x00000000                                                  );
 695:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 696:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   } 
 697:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 698:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Enable external trigger if trigger selection is different of software    */
 699:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* start.                                                                   */
 700:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Note: This configuration keeps the hardware feature of parameter         */
 701:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       ExternalTrigConvEdge "trigger edge none" equivalent to             */
 702:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*       software start.                                                    */
 703:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 704:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 759              		.loc 1 704 0
 760 0030 8C69     		ldr	r4, [r1, #24]
 761 0032 102C     		cmp	r4, #16
 762 0034 6ED0     		beq	.L83
 705:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {    
 706:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     MODIFY_REG(hadc->Instance->CR2                        ,
 763              		.loc 1 706 0
 764 0036 1D68     		ldr	r5, [r3]
 765 0038 AA68     		ldr	r2, [r5, #8]
 766 003a 22F47C12 		bic	r2, r2, #4128768
 767 003e CE69     		ldr	r6, [r1, #28]
 768 0040 3443     		orrs	r4, r4, r6
ARM GAS  /tmp/ccZBs9AV.s 			page 45


 769 0042 2243     		orrs	r2, r2, r4
 770 0044 AA60     		str	r2, [r5, #8]
 771              	.L84:
 707:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_CR2_JEXTEN  |
 708:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_CR2_JEXTSEL                            ,
 709:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                sConfigInjected->ExternalTrigInjecConv    |
 710:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                sConfigInjected->ExternalTrigInjecConvEdge  );
 711:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 712:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else
 713:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 714:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     MODIFY_REG(hadc->Instance->CR2,
 715:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_CR2_JEXTEN  |
 716:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_CR2_JEXTSEL    ,
 717:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                0x00000000          );
 718:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 719:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 720:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Configuration of injected group                                          */
 721:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Parameters update conditioned to ADC state:                              */
 722:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Parameters that can be updated only when ADC is disabled:                */
 723:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*  - Automatic injected conversion                                         */
 724:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /*  - Injected discontinuous mode                                           */
 725:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if ((ADC_IS_ENABLE(hadc) == RESET))
 772              		.loc 1 725 0
 773 0046 1A68     		ldr	r2, [r3]
 774 0048 1468     		ldr	r4, [r2]
 775 004a 14F0400F 		tst	r4, #64
 776 004e 09D1     		bne	.L85
 726:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 727:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO   |
 777              		.loc 1 727 0
 778 0050 5468     		ldr	r4, [r2, #4]
 779 0052 24F4A054 		bic	r4, r4, #5120
 780 0056 5460     		str	r4, [r2, #4]
 728:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                              ADC_CR1_JDISCEN  );
 729:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 730:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Automatic injected conversion can be enabled if injected group         */
 731:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* external triggers are disabled.                                        */
 732:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (sConfigInjected->AutoInjectedConv == ENABLE)
 781              		.loc 1 732 0
 782 0058 4A7D     		ldrb	r2, [r1, #21]	@ zero_extendqisi2
 783 005a 012A     		cmp	r2, #1
 784 005c 60D0     		beq	.L105
 785              	.LVL62:
 786              	.L86:
 733:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 734:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       if (sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 735:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 736:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         SET_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO);
 737:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 738:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       else
 739:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 740:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         /* Update ADC state machine to error */
 741:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 742:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         
 743:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         tmp_hal_status = HAL_ERROR;
 744:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 745:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
ARM GAS  /tmp/ccZBs9AV.s 			page 46


 746:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 747:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* Injected discontinuous can be enabled only if auto-injected mode is    */
 748:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     /* disabled.                                                              */  
 749:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if (sConfigInjected->InjectedDiscontinuousConvMode == ENABLE)
 787              		.loc 1 749 0
 788 005e 0A7D     		ldrb	r2, [r1, #20]	@ zero_extendqisi2
 789 0060 012A     		cmp	r2, #1
 790 0062 6CD0     		beq	.L106
 791              	.LVL63:
 792              	.L85:
 750:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 751:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       if (sConfigInjected->AutoInjectedConv == DISABLE)
 752:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 753:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         SET_BIT(hadc->Instance->CR1, ADC_CR1_JDISCEN);
 754:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       } 
 755:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       else
 756:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 757:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         /* Update ADC state machine to error */
 758:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 759:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         
 760:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         tmp_hal_status = HAL_ERROR;
 761:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 762:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 763:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 764:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** 
 765:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Channel sampling time configuration */
 766:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* For InjectedChannels 0 to 9 */
 767:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if (sConfigInjected->InjectedChannel < ADC_CHANNEL_10)
 793              		.loc 1 767 0
 794 0064 0A68     		ldr	r2, [r1]
 795 0066 092A     		cmp	r2, #9
 796 0068 77D8     		bhi	.L89
 768:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 769:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     MODIFY_REG(hadc->Instance->SMPR3,
 797              		.loc 1 769 0
 798 006a 1E68     		ldr	r6, [r3]
 799 006c 7469     		ldr	r4, [r6, #20]
 800 006e 02EB4202 		add	r2, r2, r2, lsl #1
 801 0072 0725     		movs	r5, #7
 802 0074 9540     		lsls	r5, r5, r2
 803 0076 24EA0504 		bic	r4, r4, r5
 804 007a 8D68     		ldr	r5, [r1, #8]
 805 007c 05FA02F2 		lsl	r2, r5, r2
 806 0080 2243     		orrs	r2, r2, r4
 807 0082 7261     		str	r2, [r6, #20]
 808              	.L90:
 770:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR3(ADC_SMPR3_SMP0, sConfigInjected->InjectedChannel),
 771:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR3(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) )
 772:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 773:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* For InjectedChannels 10 to 19 */
 774:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else if (sConfigInjected->InjectedChannel < ADC_CHANNEL_20)
 775:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 776:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     MODIFY_REG(hadc->Instance->SMPR2,
 777:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR2(ADC_SMPR2_SMP10, sConfigInjected->InjectedChannel),
 778:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) )
 779:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 780:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* For InjectedChannels 20 to 26 for devices Cat.1, Cat.2, Cat.3 */
ARM GAS  /tmp/ccZBs9AV.s 			page 47


 781:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* For InjectedChannels 20 to 29 for devices Cat4, Cat.5 */
 782:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else if (sConfigInjected->InjectedChannel <= ADC_SMPR1_CHANNEL_MAX)
 783:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {   
 784:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     MODIFY_REG(hadc->Instance->SMPR1,
 785:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR1(ADC_SMPR1_SMP20, sConfigInjected->InjectedChannel),
 786:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) )
 787:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 788:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* For InjectedChannels 30 to 31 for devices Cat4, Cat.5 */
 789:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   else
 790:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 791:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     ADC_SMPR0_CHANNEL_SET(hadc, sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedCha
 792:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 793:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 794:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 795:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Configure the offset: offset enable/disable, InjectedChannel, offset value */
 796:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   switch(sConfigInjected->InjectedRank)
 809              		.loc 1 796 0
 810 0084 4A68     		ldr	r2, [r1, #4]
 811 0086 022A     		cmp	r2, #2
 812 0088 00F09E80 		beq	.L94
 813 008c 032A     		cmp	r2, #3
 814 008e 00F0A580 		beq	.L95
 815 0092 012A     		cmp	r2, #1
 816 0094 00F08580 		beq	.L107
 797:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 798:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case 1:
 799:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Set injected channel 1 offset */
 800:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       MODIFY_REG(hadc->Instance->JOFR1,
 801:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR1_JOFFSET1,
 802:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  sConfigInjected->InjectedOffset);
 803:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 804:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case 2:
 805:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Set injected channel 2 offset */
 806:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       MODIFY_REG(hadc->Instance->JOFR2,
 807:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR2_JOFFSET2,
 808:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  sConfigInjected->InjectedOffset);
 809:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 810:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case 3:
 811:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Set injected channel 3 offset */
 812:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       MODIFY_REG(hadc->Instance->JOFR3,
 813:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR3_JOFFSET3,
 814:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  sConfigInjected->InjectedOffset);
 815:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
 816:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case 4:
 817:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     default:
 818:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       MODIFY_REG(hadc->Instance->JOFR4,
 817              		.loc 1 818 0
 818 0098 1C68     		ldr	r4, [r3]
 819 009a 626A     		ldr	r2, [r4, #36]
 820 009c 22F47F62 		bic	r2, r2, #4080
 821 00a0 22F00F02 		bic	r2, r2, #15
 822 00a4 CD68     		ldr	r5, [r1, #12]
 823 00a6 2A43     		orrs	r2, r2, r5
 824 00a8 6262     		str	r2, [r4, #36]
 819:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR4_JOFFSET4,
 820:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  sConfigInjected->InjectedOffset);
 821:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       break;
ARM GAS  /tmp/ccZBs9AV.s 			page 48


 825              		.loc 1 821 0
 826 00aa 83E0     		b	.L97
 827              	.LVL64:
 828              	.L104:
 643:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                    ADC_JSQR_JL   |
 829              		.loc 1 643 0
 830 00ac 1868     		ldr	r0, [r3]
 831 00ae 426C     		ldr	r2, [r0, #68]
 832 00b0 920D     		lsrs	r2, r2, #22
 833 00b2 9205     		lsls	r2, r2, #22
 834 00b4 0C68     		ldr	r4, [r1]
 835 00b6 42EAC432 		orr	r2, r2, r4, lsl #15
 836 00ba 4264     		str	r2, [r0, #68]
 603:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __IO uint32_t wait_loop_index = 0;
 837              		.loc 1 603 0
 838 00bc 0020     		movs	r0, #0
 839 00be B7E7     		b	.L81
 840              	.L79:
 668:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 841              		.loc 1 668 0
 842 00c0 4A68     		ldr	r2, [r1, #4]
 843 00c2 0C69     		ldr	r4, [r1, #16]
 844 00c4 A242     		cmp	r2, r4
 845 00c6 15D8     		bhi	.L82
 672:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  
 846              		.loc 1 672 0
 847 00c8 1F68     		ldr	r7, [r3]
 848 00ca 7D6C     		ldr	r5, [r7, #68]
 849 00cc 101B     		subs	r0, r2, r4
 850 00ce 00EB8000 		add	r0, r0, r0, lsl #2
 851 00d2 0F30     		adds	r0, r0, #15
 852 00d4 1F22     		movs	r2, #31
 853 00d6 8240     		lsls	r2, r2, r0
 854 00d8 42F44012 		orr	r2, r2, #3145728
 855 00dc 25EA0205 		bic	r5, r5, r2
 856 00e0 621E     		subs	r2, r4, #1
 857 00e2 0E68     		ldr	r6, [r1]
 858 00e4 06FA00F0 		lsl	r0, r6, r0
 859 00e8 40EA0252 		orr	r2, r0, r2, lsl #20
 860 00ec 2A43     		orrs	r2, r2, r5
 861 00ee 7A64     		str	r2, [r7, #68]
 603:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __IO uint32_t wait_loop_index = 0;
 862              		.loc 1 603 0
 863 00f0 0020     		movs	r0, #0
 864 00f2 9DE7     		b	.L81
 865              	.L82:
 687:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  
 866              		.loc 1 687 0
 867 00f4 1E68     		ldr	r6, [r3]
 868 00f6 756C     		ldr	r5, [r6, #68]
 869 00f8 121B     		subs	r2, r2, r4
 870 00fa 02EB8202 		add	r2, r2, r2, lsl #2
 871 00fe 0F32     		adds	r2, r2, #15
 872 0100 1F20     		movs	r0, #31
 873 0102 00FA02F2 		lsl	r2, r0, r2
 874 0106 42F44012 		orr	r2, r2, #3145728
 875 010a 25EA0202 		bic	r2, r5, r2
ARM GAS  /tmp/ccZBs9AV.s 			page 49


 876 010e 7264     		str	r2, [r6, #68]
 603:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __IO uint32_t wait_loop_index = 0;
 877              		.loc 1 603 0
 878 0110 0020     		movs	r0, #0
 879 0112 8DE7     		b	.L81
 880              	.LVL65:
 881              	.L83:
 714:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_CR2_JEXTEN  |
 882              		.loc 1 714 0
 883 0114 1C68     		ldr	r4, [r3]
 884 0116 A268     		ldr	r2, [r4, #8]
 885 0118 22F47C12 		bic	r2, r2, #4128768
 886 011c A260     		str	r2, [r4, #8]
 887 011e 92E7     		b	.L84
 888              	.L105:
 734:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 889              		.loc 1 734 0
 890 0120 8A69     		ldr	r2, [r1, #24]
 891 0122 102A     		cmp	r2, #16
 892 0124 05D0     		beq	.L108
 741:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         
 893              		.loc 1 741 0
 894 0126 DA6C     		ldr	r2, [r3, #76]
 895 0128 42F02002 		orr	r2, r2, #32
 896 012c DA64     		str	r2, [r3, #76]
 897              	.LVL66:
 743:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 898              		.loc 1 743 0
 899 012e 0120     		movs	r0, #1
 900 0130 95E7     		b	.L86
 901              	.LVL67:
 902              	.L108:
 736:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 903              		.loc 1 736 0
 904 0132 1C68     		ldr	r4, [r3]
 905 0134 6268     		ldr	r2, [r4, #4]
 906 0136 42F48062 		orr	r2, r2, #1024
 907 013a 6260     		str	r2, [r4, #4]
 908 013c 8FE7     		b	.L86
 909              	.L106:
 751:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 910              		.loc 1 751 0
 911 013e 4A7D     		ldrb	r2, [r1, #21]	@ zero_extendqisi2
 912 0140 2AB9     		cbnz	r2, .L88
 753:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       } 
 913              		.loc 1 753 0
 914 0142 1C68     		ldr	r4, [r3]
 915 0144 6268     		ldr	r2, [r4, #4]
 916 0146 42F48052 		orr	r2, r2, #4096
 917 014a 6260     		str	r2, [r4, #4]
 918 014c 8AE7     		b	.L85
 919              	.L88:
 758:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         
 920              		.loc 1 758 0
 921 014e DA6C     		ldr	r2, [r3, #76]
 922 0150 42F02002 		orr	r2, r2, #32
 923 0154 DA64     		str	r2, [r3, #76]
ARM GAS  /tmp/ccZBs9AV.s 			page 50


 924              	.LVL68:
 760:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 925              		.loc 1 760 0
 926 0156 0120     		movs	r0, #1
 927 0158 84E7     		b	.L85
 928              	.LVL69:
 929              	.L89:
 774:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 930              		.loc 1 774 0
 931 015a 132A     		cmp	r2, #19
 932 015c 0ED8     		bhi	.L91
 776:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR2(ADC_SMPR2_SMP10, sConfigInjected->InjectedChannel),
 933              		.loc 1 776 0
 934 015e 1E68     		ldr	r6, [r3]
 935 0160 3469     		ldr	r4, [r6, #16]
 936 0162 02EB4202 		add	r2, r2, r2, lsl #1
 937 0166 1E3A     		subs	r2, r2, #30
 938 0168 0725     		movs	r5, #7
 939 016a 9540     		lsls	r5, r5, r2
 940 016c 24EA0504 		bic	r4, r4, r5
 941 0170 8D68     		ldr	r5, [r1, #8]
 942 0172 05FA02F2 		lsl	r2, r5, r2
 943 0176 2243     		orrs	r2, r2, r4
 944 0178 3261     		str	r2, [r6, #16]
 945 017a 83E7     		b	.L90
 946              	.L91:
 782:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {   
 947              		.loc 1 782 0
 948 017c 1A2A     		cmp	r2, #26
 949 017e 0ED8     		bhi	.L92
 784:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                ADC_SMPR1(ADC_SMPR1_SMP20, sConfigInjected->InjectedChannel),
 950              		.loc 1 784 0
 951 0180 1E68     		ldr	r6, [r3]
 952 0182 F468     		ldr	r4, [r6, #12]
 953 0184 02EB4202 		add	r2, r2, r2, lsl #1
 954 0188 3C3A     		subs	r2, r2, #60
 955 018a 0725     		movs	r5, #7
 956 018c 9540     		lsls	r5, r5, r2
 957 018e 24EA0504 		bic	r4, r4, r5
 958 0192 8D68     		ldr	r5, [r1, #8]
 959 0194 05FA02F2 		lsl	r2, r5, r2
 960 0198 2243     		orrs	r2, r2, r4
 961 019a F260     		str	r2, [r6, #12]
 962 019c 72E7     		b	.L90
 963              	.L92:
 791:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 964              		.loc 1 791 0
 965              		.syntax unified
 966              	@ 791 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c" 1
 967 019e 00BF     		nop
 968              	@ 0 "" 2
 969              		.thumb
 970              		.syntax unified
 971 01a0 70E7     		b	.L90
 972              	.L107:
 800:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR1_JOFFSET1,
 973              		.loc 1 800 0
ARM GAS  /tmp/ccZBs9AV.s 			page 51


 974 01a2 1C68     		ldr	r4, [r3]
 975 01a4 A269     		ldr	r2, [r4, #24]
 976 01a6 22F47F62 		bic	r2, r2, #4080
 977 01aa 22F00F02 		bic	r2, r2, #15
 978 01ae CD68     		ldr	r5, [r1, #12]
 979 01b0 2A43     		orrs	r2, r2, r5
 980 01b2 A261     		str	r2, [r4, #24]
 981              	.L97:
 822:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 823:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 824:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
 825:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* and VREFINT measurement path.                                            */
 826:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
 982              		.loc 1 826 0
 983 01b4 0A68     		ldr	r2, [r1]
 984 01b6 103A     		subs	r2, r2, #16
 985 01b8 012A     		cmp	r2, #1
 986 01ba 19D9     		bls	.L109
 987              	.LVL70:
 988              	.L98:
 827:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)      )
 828:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   {
 829:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     SET_BIT(ADC->CCR, ADC_CCR_TSVREFE);
 830:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 831:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR))
 832:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 833:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Delay for temperature sensor stabilization time */
 834:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       /* Compute number of CPU cycles to wait for */
 835:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 836:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       while(wait_loop_index != 0)
 837:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 838:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****         wait_loop_index--;
 839:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 840:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     }
 841:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   }
 842:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 843:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Process unlocked */
 844:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   __HAL_UNLOCK(hadc);
 989              		.loc 1 844 0
 990 01bc 0022     		movs	r2, #0
 991 01be 83F84820 		strb	r2, [r3, #72]
 992              	.LVL71:
 993              	.L78:
 845:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 846:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   /* Return function status */
 847:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   return tmp_hal_status;
 848:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c **** }
 994              		.loc 1 848 0
 995 01c2 02B0     		add	sp, sp, #8
 996              	.LCFI9:
 997              		.cfi_remember_state
 998              		.cfi_def_cfa_offset 16
 999              		@ sp needed
 1000 01c4 F0BC     		pop	{r4, r5, r6, r7}
 1001              	.LCFI10:
 1002              		.cfi_restore 7
 1003              		.cfi_restore 6
ARM GAS  /tmp/ccZBs9AV.s 			page 52


 1004              		.cfi_restore 5
 1005              		.cfi_restore 4
 1006              		.cfi_def_cfa_offset 0
 1007 01c6 7047     		bx	lr
 1008              	.LVL72:
 1009              	.L94:
 1010              	.LCFI11:
 1011              		.cfi_restore_state
 806:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR2_JOFFSET2,
 1012              		.loc 1 806 0
 1013 01c8 1C68     		ldr	r4, [r3]
 1014 01ca E269     		ldr	r2, [r4, #28]
 1015 01cc 22F47F62 		bic	r2, r2, #4080
 1016 01d0 22F00F02 		bic	r2, r2, #15
 1017 01d4 CD68     		ldr	r5, [r1, #12]
 1018 01d6 2A43     		orrs	r2, r2, r5
 1019 01d8 E261     		str	r2, [r4, #28]
 809:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case 3:
 1020              		.loc 1 809 0
 1021 01da EBE7     		b	.L97
 1022              	.L95:
 812:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****                  ADC_JOFR3_JOFFSET3,
 1023              		.loc 1 812 0
 1024 01dc 1C68     		ldr	r4, [r3]
 1025 01de 226A     		ldr	r2, [r4, #32]
 1026 01e0 22F47F62 		bic	r2, r2, #4080
 1027 01e4 22F00F02 		bic	r2, r2, #15
 1028 01e8 CD68     		ldr	r5, [r1, #12]
 1029 01ea 2A43     		orrs	r2, r2, r5
 1030 01ec 2262     		str	r2, [r4, #32]
 815:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     case 4:
 1031              		.loc 1 815 0
 1032 01ee E1E7     		b	.L97
 1033              	.L109:
 829:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     
 1034              		.loc 1 829 0
 1035 01f0 0D4C     		ldr	r4, .L110
 1036 01f2 6268     		ldr	r2, [r4, #4]
 1037 01f4 42F40002 		orr	r2, r2, #8388608
 1038 01f8 6260     		str	r2, [r4, #4]
 831:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****     {
 1039              		.loc 1 831 0
 1040 01fa 0A68     		ldr	r2, [r1]
 1041 01fc 102A     		cmp	r2, #16
 1042 01fe DDD1     		bne	.L98
 835:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       while(wait_loop_index != 0)
 1043              		.loc 1 835 0
 1044 0200 0A4A     		ldr	r2, .L110+4
 1045 0202 1268     		ldr	r2, [r2]
 1046 0204 0A49     		ldr	r1, .L110+8
 1047              	.LVL73:
 1048 0206 A1FB0212 		umull	r1, r2, r1, r2
 1049 020a 920C     		lsrs	r2, r2, #18
 1050 020c 02EB8202 		add	r2, r2, r2, lsl #2
 1051 0210 5100     		lsls	r1, r2, #1
 1052 0212 0191     		str	r1, [sp, #4]
 1053              	.L99:
ARM GAS  /tmp/ccZBs9AV.s 			page 53


 836:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       {
 1054              		.loc 1 836 0
 1055 0214 019A     		ldr	r2, [sp, #4]
 1056 0216 002A     		cmp	r2, #0
 1057 0218 D0D0     		beq	.L98
 838:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****       }
 1058              		.loc 1 838 0
 1059 021a 019A     		ldr	r2, [sp, #4]
 1060 021c 013A     		subs	r2, r2, #1
 1061 021e 0192     		str	r2, [sp, #4]
 1062 0220 F8E7     		b	.L99
 1063              	.LVL74:
 1064              	.L101:
 627:..//Source/stm/lib/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal_adc_ex.c ****   
 1065              		.loc 1 627 0
 1066 0222 0220     		movs	r0, #2
 1067 0224 CDE7     		b	.L78
 1068              	.L111:
 1069 0226 00BF     		.align	2
 1070              	.L110:
 1071 0228 00270140 		.word	1073817344
 1072 022c 00000000 		.word	SystemCoreClock
 1073 0230 83DE1B43 		.word	1125899907
 1074              		.cfi_endproc
 1075              	.LFE79:
 1077              		.text
 1078              	.Letext0:
 1079              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 1080              		.file 4 "/usr/include/newlib/sys/_stdint.h"
 1081              		.file 5 "..//Source/stm/lib/CMSIS/Include/core_cm3.h"
 1082              		.file 6 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/system_stm32l1xx.h"
 1083              		.file 7 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/stm32l151xba.h"
 1084              		.file 8 "..//Source/stm/lib/CMSIS/Device/ST/STM32L1xx/Include/stm32l1xx.h"
 1085              		.file 9 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal_def.h"
 1086              		.file 10 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal_dma.h"
 1087              		.file 11 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal_adc.h"
 1088              		.file 12 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal_adc_ex.h"
 1089              		.file 13 "..//Source/stm/lib/STM32L1xx_HAL_Driver/Inc/stm32l1xx_hal.h"
ARM GAS  /tmp/ccZBs9AV.s 			page 54


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32l1xx_hal_adc_ex.c
     /tmp/ccZBs9AV.s:16     .text.HAL_ADCEx_InjectedStart:0000000000000000 $t
     /tmp/ccZBs9AV.s:23     .text.HAL_ADCEx_InjectedStart:0000000000000000 HAL_ADCEx_InjectedStart
     /tmp/ccZBs9AV.s:102    .text.HAL_ADCEx_InjectedStop:0000000000000000 $t
     /tmp/ccZBs9AV.s:109    .text.HAL_ADCEx_InjectedStop:0000000000000000 HAL_ADCEx_InjectedStop
     /tmp/ccZBs9AV.s:188    .text.HAL_ADCEx_InjectedPollForConversion:0000000000000000 $t
     /tmp/ccZBs9AV.s:195    .text.HAL_ADCEx_InjectedPollForConversion:0000000000000000 HAL_ADCEx_InjectedPollForConversion
     /tmp/ccZBs9AV.s:438    .text.HAL_ADCEx_InjectedPollForConversion:0000000000000150 $d
     /tmp/ccZBs9AV.s:445    .text.HAL_ADCEx_InjectedStart_IT:0000000000000000 $t
     /tmp/ccZBs9AV.s:452    .text.HAL_ADCEx_InjectedStart_IT:0000000000000000 HAL_ADCEx_InjectedStart_IT
     /tmp/ccZBs9AV.s:535    .text.HAL_ADCEx_InjectedStop_IT:0000000000000000 $t
     /tmp/ccZBs9AV.s:542    .text.HAL_ADCEx_InjectedStop_IT:0000000000000000 HAL_ADCEx_InjectedStop_IT
     /tmp/ccZBs9AV.s:626    .text.HAL_ADCEx_InjectedGetValue:0000000000000000 $t
     /tmp/ccZBs9AV.s:633    .text.HAL_ADCEx_InjectedGetValue:0000000000000000 HAL_ADCEx_InjectedGetValue
     /tmp/ccZBs9AV.s:682    .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000000 $t
     /tmp/ccZBs9AV.s:689    .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000000 HAL_ADCEx_InjectedConvCpltCallback
     /tmp/ccZBs9AV.s:702    .text.HAL_ADCEx_InjectedConfigChannel:0000000000000000 $t
     /tmp/ccZBs9AV.s:709    .text.HAL_ADCEx_InjectedConfigChannel:0000000000000000 HAL_ADCEx_InjectedConfigChannel
     /tmp/ccZBs9AV.s:1071   .text.HAL_ADCEx_InjectedConfigChannel:0000000000000228 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
ADC_Enable
ADC_ConversionStop_Disable
HAL_GetTick
SystemCoreClock
